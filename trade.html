<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <title>Stryke.xyz - Trade</title>
    <!-- Import Inter Font -->
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js & chartjs-plugin-annotation -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0"></script>
    
    <!-- Fresh implementation for chain-grouped market selector -->
    <script>
      // Chain information for the market selector
      const CHAIN_DATA = {
        42161: { 
          name: "Arbitrum", 
          color: "#2D374B", 
          logo: "https://www.stryke.xyz/images/tokens/arb.svg"
        },
        146: { 
          name: "Sonic", 
          color: "#FF0420", 
          logo: "https://www.stryke.xyz/images/tokens/ws.svg"
        },
        80094: { 
          name: "Berachain", 
          color: "#FAC807", 
          logo: "https://www.stryke.xyz/_next/image?url=%2Fimages%2Ftokens%2Fbera.png&w=48&q=75"
        },
        5000: { 
          name: "Mantle", 
          color: "#0B1811", 
          logo: "https://www.stryke.xyz/images/tokens/wmnt.svg"
        },
        81457: { 
          name: "Blast", 
          color: "#FF4500", 
          logo: "https://www.stryke.xyz/_next/image?url=%2Fimages%2Ftokens%2Fblast.png&w=48&q=75"
        },
        8453: { 
          name: "Base", 
          color: "#0052FF", 
          logo: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='28'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cpath fill='%230052FF' fill-rule='nonzero' d='M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z'/%3E%3Cpath fill='%23FFF' d='M13.967 23.86c5.445 0 9.86-4.415 9.86-9.86 0-5.445-4.415-9.86-9.86-9.86-5.166 0-9.403 3.974-9.825 9.03h14.63v1.642H4.142c.413 5.065 4.654 9.047 9.826 9.047Z'/%3E%3C/g%3E%3C/svg%3E"
        }
      };

      // Function to fetch markets and group them by chain
      async function fetchAndGroupMarkets() {
        try {
          console.log("Fetching markets from API...");
          
          // Fetch all markets
          const response = await fetch('https://api.stryke.xyz/v1.1/clamm/option-markets?chains=42161%2C146%2C8453%2C81457%2C5000%2C80094');
          const markets = await response.json();
          
          console.log("Markets fetched:", markets.length);
          
          // Group markets by chainId
          const marketsByChain = {};
          markets.forEach(market => {
            if (!market.deprecated) {
              const chainId = market.chainId.toString();
              if (!marketsByChain[chainId]) {
                marketsByChain[chainId] = [];
              }
              marketsByChain[chainId].push(market);
            }
          });
          
          // Store global markets data if needed
          window.marketsData = markets;
          
          return {
            allMarkets: markets,
            marketsByChain: marketsByChain
          };
        } catch (error) {
          console.error('Error fetching markets:', error);
          return {
            allMarkets: [],
            marketsByChain: {}
          };
        }
      }

      // Function to populate the market dropdown with chain grouping
      function populateChainGroupedDropdown(marketSelect, marketsByChain) {
        if (!marketSelect || !marketsByChain) {
          console.error("Invalid inputs to populateChainGroupedDropdown");
          return null;
        }
        
        // Clear existing options
        marketSelect.innerHTML = '';
        
        // Sort chains by name
        const sortedChainIds = Object.keys(marketsByChain).sort((a, b) => {
          const chainA = CHAIN_DATA[a] || { name: "Unknown" };
          const chainB = CHAIN_DATA[b] || { name: "Unknown" };
          return chainA.name.localeCompare(chainB.name);
        });
        
        let firstMarketAddress = null;
        
        // Add markets by chain groups
        sortedChainIds.forEach(chainId => {
          const chain = CHAIN_DATA[chainId] || { name: `Chain ${chainId}`, color: "#999" };
          
          // Create optgroup for the chain
          const optgroup = document.createElement('optgroup');
          optgroup.label = chain.name;
          optgroup.style.backgroundColor = chain.color;
          optgroup.style.color = "white";
          optgroup.style.fontWeight = "bold";
          
          // Sort markets by liquidity (highest first)
          const sortedMarkets = marketsByChain[chainId].sort((a, b) => 
            (b.totalLiquidity || 0) - (a.totalLiquidity || 0)
          );
          
          // Add markets for this chain
          sortedMarkets.forEach(market => {
            const option = document.createElement('option');
            option.value = market.address;
            option.textContent = market.pairName;
            optgroup.appendChild(option);
            
            // Store first market address
            if (!firstMarketAddress) {
              firstMarketAddress = market.address;
            }
          });
          
          marketSelect.appendChild(optgroup);
        });
        
        // Add custom styles for the dropdown
        addDropdownStyles();
        
        return firstMarketAddress;
      }
      
      // Function to add custom styles for the dropdown
      function addDropdownStyles() {
        const styleId = 'chain-dropdown-styles';
        if (!document.getElementById(styleId)) {
          const style = document.createElement('style');
          style.id = styleId;
          style.textContent = `
            optgroup {
              padding: 5px;
              margin-top: 5px;
              border-radius: 4px;
            }
            option {
              padding-left: 10px;
            }
          `;
          document.head.appendChild(style);
        }
      }

      // Function to initialize the market selection
      async function initializeMarketSelection() {
        // Get the market select element
        const marketSelect = document.getElementById('marketSelect');
        if (!marketSelect) {
          console.error("Market select element not found!");
          return;
        }
        
        // Fetch and group markets
        const { allMarkets, marketsByChain } = await fetchAndGroupMarkets();
        
        // Populate the dropdown
        const firstMarketAddress = populateChainGroupedDropdown(marketSelect, marketsByChain);
        
        // Select the first market
        if (firstMarketAddress) {
          console.log("Setting initial market:", firstMarketAddress);
          marketSelect.value = firstMarketAddress;
          
          // Trigger market data loading - ensure this function exists in your code
          if (typeof fetchMarketData === 'function') {
            fetchMarketData(firstMarketAddress);
          } else {
            console.warn("fetchMarketData function not found. Please load market data manually.");
          }
        }
        
        // Add change event listener
        marketSelect.addEventListener('change', function() {
          const selectedMarketAddress = this.value;
          console.log("Market changed:", selectedMarketAddress);
          
          // Load selected market data
          if (typeof fetchMarketData === 'function') {
            fetchMarketData(selectedMarketAddress);
          }
        });
      }

      // Initialize when the document is ready
      document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM loaded, initializing market selection...");
        initializeMarketSelection();
      });
    </script>
    
    <script>
      tailwind.config = {
        darkMode: "class",
        theme: {
          extend: {
            fontFamily: { sans: ["Inter", "sans-serif"] },
            colors: {
              primary: "#FBBF24",
              bullishGreen: "#2ecc71",
              neonGreen: "#0FFF95",
              lightOrange: "#FDBA74"
            },
            backgroundImage: {
              "grain-light": "url('https://www.transparenttextures.com/patterns/dark-matter.png')"
            },
            boxShadow: {
              card: "0 4px 6px rgba(0,0,0,0.1)",
              "3d": "0 10px 30px rgba(0,0,0,0.6)"
            }
          }
        }
      };
    </script>
    <style>
      :root {
        --highlight-color: #0FFF95;
      }
      /* Dark mode styles */
      .dark {
        --bg-color: #121212;
        --surface-color: #1E1E1E;
        --primary-color: #0FFF95;
        --secondary-color: #f0f0f0;
        color-scheme: dark;
      }
      /* Light mode styles */
      :root:not(.dark) {
        --bg-color: #f0f0f0;
        --surface-color: #ffffff;
        --primary-color: #106B4E;
        --secondary-color: #121212;
        color-scheme: light;
      }

      /* Enhanced market dropdown styles */
      #marketDropdownButton {
        transition: all 0.2s ease;
        min-height: 38px;
      }
      
      #marketDropdownButton:hover {
        border-color: var(--highlight-color);
      }
      
      #marketDropdownList {
        transition: opacity 0.15s ease, transform 0.15s ease;
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
        max-height: 320px;
        transform-origin: top center;
      }
      
      #marketDropdownList.hidden {
        opacity: 0;
        transform: translateY(-10px);
        pointer-events: none;
      }
      
      #marketDropdownList:not(.hidden) {
        opacity: 1;
        transform: translateY(0);
      }
      
      #marketDropdownList > div {
        transition: background-color 0.15s ease;
      }
      
      #marketDropdownList > div:hover {
        background-color: rgba(15, 255, 149, 0.1);
      }
      
      /* Market metrics badges */
      .market-metric {
        display: inline-flex;
        flex-direction: column;
        gap: 2px;
      }
      
      .market-metric-value {
        font-weight: 500;
      }
      
      /* Sort buttons */
      #sortByName, #sortByLiquidity, #sortByVolume {
        transition: color 0.2s ease;
        cursor: pointer;
        padding: 2px 4px;
        border-radius: 4px;
      }
      
      .sort-active {
        color: #0FFF95 !important;
        font-weight: 500;
        position: relative;
      }
      
      .sort-active::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 100%;
        height: 2px;
        background-color: #0FFF95;
        border-radius: 1px;
      }
      
      /* Scrollbar styling */
      #marketDropdownList::-webkit-scrollbar {
        width: 6px;
      }
      
      #marketDropdownList::-webkit-scrollbar-track {
        background: #2A2A2A;
      }
      
      #marketDropdownList::-webkit-scrollbar-thumb {
        background: #4B5563;
        border-radius: 3px;
      }
      
      #marketDropdownList::-webkit-scrollbar-thumb:hover {
        background: #606770;
      }

      body {
        margin: 0;
        font-family: 'Inter', sans-serif;
        background-color: #121212;
        color: white;
      }
      /* Neumorphic Sunken Effect for Inputs */
      .neumorphic-sunken {
        background: #e0e0e0;
        border-radius: 0.375rem;
        box-shadow: inset 5px 5px 10px rgba(0,0,0,0.2),
          inset -5px -5px 10px rgba(255,255,255,0.7);
        color: #fff;
      }
      .dark .neumorphic-sunken {
        background: #1F1F1F;
        box-shadow: inset 5px 5px 10px rgba(0,0,0,0.9),
          inset -5px -5px 10px rgba(50,50,50,0.7);
        color: #fff;
      }
      /* 3D Effect for Buttons */
      .btn-3d {
        background: linear-gradient(145deg, #2ecc71, #0FFF95);
        box-shadow: 5px 5px 10px rgba(0,0,0,0.2),
          -3px -3px 6px rgba(255,255,255,0.8),
          inset 2px 2px 4px rgba(255,255,255,0.5),
          inset -3px -3px 5px rgba(0,0,0,0.2);
        border: none;
        border-radius: 0.375rem;
        color: black;
      }
      .btn-3d:active {
        box-shadow: inset 5px 5px 10px rgba(0,0,0,0.3),
          inset -3px -3px 6px rgba(255,255,255,0.8);
        background: linear-gradient(145deg, #0FFF95, #2ecc71);
      }
      .dark .btn-3d {
        background: linear-gradient(145deg, #2ecc71, #0FFF95);
        box-shadow: 5px 5px 10px rgba(0,0,0,0.5),
          -3px -3px 6px rgba(0,0,0,0.4),
          inset 2px 2px 4px rgba(0,0,0,0.6),
          inset -3px -3px 5px rgba(0,0,0,0.5);
        color: black;
      }
      .dark .btn-3d:active {
        box-shadow: inset 5px 5px 10px rgba(0,0,0,0.7),
          inset -3px -3px 6px rgba(0,0,0,0.6);
        background: linear-gradient(145deg, #0FFF95, #2ecc71);
      }
      
      /* Option Type Toggle SVG Handling */
      .option-type-toggle button.active svg path {
        stroke: #000000 !important;
      }
      
      /* 3D Effect for Dropdown Selectors */
      .select-3d {
        background: linear-gradient(145deg, #e5e7eb, #d1d5db);
        box-shadow: 5px 5px 10px rgba(0,0,0,0.2),
          -3px -3px 6px rgba(255,255,255,0.8),
          inset 2px 2px 4px rgba(255,255,255,0.5),
          inset -3px -3px 5px rgba(0,0,0,0.2);
        border: none;
        color: #fff;
      }
      .dark .select-3d {
        background: linear-gradient(145deg, #2e2e2e, #1A1A1A);
        box-shadow: 5px 5px 10px rgba(0,0,0,0.5),
          -3px -3px 6px rgba(0,0,0,0.4),
          inset 2px 2px 4px rgba(0,0,0,0.6),
          inset -3px -3px 5px rgba(0,0,0,0.5);
        color: #fff;
      }
      /* 3D Effect for Table Headers */
      .table-3d th {
        background: linear-gradient(145deg, #e5e7eb, #d1d5db);
        box-shadow: 2px 2px 4px rgba(0,0,0,0.2), inset -2px -2px 4px rgba(255,255,255,0.5);
        color: black;
      }
      .dark .table-3d th {
        background: linear-gradient(145deg, #2e2e2e, #1A1A1A);
        box-shadow: 2px 2px 4px rgba(0,0,0,0.5), inset -2px -2px 4px rgba(0,0,0,0.3);
        color: white;
      }
      /* Dual-line styling for cell values */
      .primary-value {
        font-size: 1rem;
        font-weight: 600;
      }
      .secondary-value {
        font-size: 0.75rem;
        color: rgba(107,114,128,0.8);
      }
      .dark .secondary-value {
        color: rgba(156,163,175,0.8);
      }
      /* Log Button */
      .log-button {
        font-size: 0.75rem;
        color: #fff;
        border: none;
        background: none;
        cursor: pointer;
        transition: color 0.2s;
      }
      .log-button.active {
        color: #0FFF95;
      }
      /* 3-Way Toggle Styles (for product type only) */
      .threeway-toggle {
        display: inline-flex;
        border: 1px solid #4B5563;
        border-radius: 0.375rem;
        overflow: hidden;
        margin-bottom: 0.5rem;
      }
      .threeway-toggle button {
        padding: 0.5rem 1rem;
        font-size: 0.875rem;
        background-color: transparent;
        color: #D1D5DB;
        border: none;
        cursor: pointer;
        transition: background-color 0.2s, color 0.2s;
      }
      .threeway-toggle button.active {
        background-color: #0FFF95;
        color: black;
      }
      .threeway-toggle button:not(:last-child) {
        border-right: 1px solid #4B5563;
      }
      /* Control Labels */
      .control-label {
        font-size: 0.75rem;
        font-weight: 500;
        color: #fff;
      }
      /* Table Overrides for Dark Mode */
      table#liquidityTable td {
        background-color: #1a1a1a !important;
        color: #fff !important;
        border: 1px solid #444 !important;
        padding: 8px !important;
      }
      table#liquidityTable th {
        background-color: transparent !important;
        color: #ffcc00 !important;
        border: 1px solid #444 !important;
        padding: 8px !important;
      }
      /* Zoom Presets Button Styles */
      .zoom-preset-btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        border: 1px solid #4B5563;
        border-radius: 0.375rem;
        margin-right: 0.5rem;
        cursor: pointer;
        background-color: transparent;
        color: #D1D5DB;
        transition: background-color 0.2s, color 0.2s;
      }
      .zoom-preset-btn.active {
        background-color: #0FFF95;
        color: black;
      }
      /* Ensure dark-mode dropdown text is visible */
      input.neumorphic-sunken, .select-3d { color: #fff; }
      /* Slider styling */
      .slider {
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        width: 100px;
        height: 4px;
        background: #ddd;
        outline: none;
        border-radius: 2px;
        transition: background-color 0.2s ease-in-out;
      }
      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0FFF95;
        cursor: pointer;
        transition: transform 0.1s;
      }
      .slider::-webkit-slider-thumb:hover {
        transform: scale(1.1);
      }
      .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #0FFF95;
        cursor: pointer;
        transition: transform 0.1s;
      }
      .slider::-moz-range-thumb:hover {
        transform: scale(1.1);
      }
      /* Liquidity display next to slider */
      .liquidity-display {
        font-size: 0.75rem;
        color: #fff;
        margin-top: 0.25rem;
        text-align: center;
      }
      /* Modal Popup Styles */
      .modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0,0,0,0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
      }
      .modal.active {
        display: flex;
      }
      .modal-content {
        background: #1A1F1F;
        border-radius: 0.375rem;
        box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        padding: 1rem;
        width: 90%;
        max-width: 800px;
      }
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .modal-header h2 {
        color: #fff;
      }
      .modal-close {
        font-size: 1.5rem;
        color: #0FFF95;
        cursor: pointer;
      }
      .modal-tabs {
        display: flex;
        margin-top: 1rem;
        border-bottom: 1px solid #4B5563;
      }
      .modal-tab {
        padding: 0.5rem 1rem;
        cursor: pointer;
        color: #D1D5DB;
      }
      .modal-tab.active {
        border-bottom: 2px solid #0FFF95;
        color: black;
        background-color: #0FFF95;
      }
      .modal-body {
        margin-top: 1rem;
      }
      /* Custom styles for min/max inputs */
      .compact-input {
        height: 28px;
        padding: 0.25rem 0.5rem;
      }
      
      /* Chart Container */
      .chart-container {
        width: 100%;
        height: 400px;
        margin: 0 auto;
      }
      /* Input placeholders */
      .neumorphic-sunken::placeholder {
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.75rem;
        font-weight: 500;
        opacity: 1; /* Firefox */
      }
      
      /* Compact input style for min/max inputs */
      .compact-input {
        padding: 0.5rem 0.75rem;
        height: 2.5rem;
      }
      
      /* Input with arrow indicators */
      .input-wrapper {
        position: relative;
        width: 100%;
      }
      
      .input-with-left-arrow {
        padding-left: 1.75rem !important;
      }
      
      .input-with-right-arrow {
        padding-right: 1.75rem !important;
      }
      
      .arrow-indicator {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        color: rgba(255, 255, 255, 0.5);
        font-size: 0.875rem;
        pointer-events: none;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 1.25rem;
        height: 1.25rem;
        transition: color 0.2s;
      }
      
      /* Input focus affects the arrow color */
      .input-wrapper input:focus + .arrow-indicator,
      .input-wrapper input:focus ~ .arrow-indicator {
        color: rgba(15, 255, 149, 0.8); /* Green color to match the focus ring */
      }
      
      .arrow-left {
        left: 0.5rem;
      }
      
      .arrow-right {
        right: 0.5rem;
      }
      
      /* Amount input with MAX button */
      .amount-input-wrapper {
        position: relative;
        margin-bottom: 0.5rem;
      }
      
      .amount-input {
        padding-right: 4rem !important; /* Space for the MAX button */
      }
      
      .max-button {
        position: absolute;
        right: 2px;
        top: 2px;
        bottom: 2px;
        background-color: rgba(15, 255, 149, 0.2);
        color: rgba(15, 255, 149, 1);
        border: none;
        border-radius: 0.375rem;
        font-size: 0.75rem;
        font-weight: 600;
        padding: 0 0.75rem;
        cursor: pointer;
        transition: background-color 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .max-button:hover {
        background-color: rgba(15, 255, 149, 0.3);
      }
      
      /* Available liquidity text */
      .available-liquidity {
        font-size: 0.7rem;
        color: rgba(255, 255, 255, 0.5);
        text-align: right;
        margin-bottom: 0.25rem;
      }
      
      /* Custom styles for the custom dropdown */
    </style>
  </head>
  <body class="font-sans bg-grain-light dark:bg-[#1F1F1F] bg-cover bg-center bg-no-repeat transition-colors duration-300 min-h-screen">
    <!-- Top Navigation Bar -->
    <header class="bg-[#1A1A1A] shadow-3d z-50 relative">
      <div class="max-w-7xl mx-auto px-4 py-4 flex items-center justify-between">
        <div class="flex items-center space-x-4">
          <img src="https://www.stryke.xyz/images/brand/logo.ico" alt="Stryke Logo" class="w-10 h-10 rounded-full" />
          <nav class="flex items-center space-x-6 text-sm">
            <a href="trade.html" class="text-neonGreen font-bold transition border-b-2 border-neonGreen">Trade</a>
            <a href="earn.html" class="text-white hover:opacity-80 transition">Earn</a>
          </nav>
        </div>
        <button id="modeToggle" class="p-2 transition transform hover:scale-105 focus:outline-none">
          <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-green-400 dark:hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M12 3v1m0 16v1m8.66-9H21m-16 0H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M12 8a4 4 0 110 8 4 4 0 010-8z" />
          </svg>
          <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-green-400 hidden dark:block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />
          </svg>
        </button>
      </div>
    </header>
    
    <!-- Main Section (Options UI) -->
    <section id="liquidityChartSection" class="max-w-7xl mx-auto px-4 mt-6 mb-8 relative">
      <div class="flex space-x-6">
        <!-- Main Chart Panel -->
        <div class="flex-grow relative bg-gray-200 dark:bg-[#1F1F1F] rounded-lg shadow-3d p-4">
          <!-- Market Info Panel - Moved to the very top -->
          <div class="bg-[#1A1A1A] rounded-md mb-3 p-3 flex items-center justify-between text-white border border-[#0FFF95] shadow-md">
            <div class="flex-1 flex flex-col items-center border-r border-gray-700 px-2">
              <span class="text-xs text-gray-400">Price</span>
              <span id="marketInfoPrice" class="text-lg font-bold">--</span>
            </div>
            <div class="flex-1 flex flex-col items-center border-r border-gray-700 px-2">
              <span class="text-xs text-gray-400">Total Liquidity</span>
              <span id="marketInfoLiquidity" class="text-lg font-bold">--</span>
            </div>
            <div class="flex-1 flex flex-col items-center border-r border-gray-700 px-2">
              <span class="text-xs text-gray-400">Open Interest</span>
              <span id="marketInfoOpenInterest" class="text-lg font-bold">--</span>
            </div>
            <div class="flex-1 flex flex-col items-center px-2">
              <span class="text-xs text-gray-400">24h Volume</span>
              <span id="marketInfoVolume" class="text-lg font-bold">--</span>
            </div>
          </div>
          
        <!-- Product Type Toggle (Spot/Options/Perp) -->
          <div class="flex items-center justify-between mb-2">
            <!-- Left side: Market selector styled like toggle (label removed) -->
            <div>
              <div class="relative inline-block">
                <div id="marketSelectContainer" class="relative w-64">
                  <button id="marketDropdownButton" class="appearance-none cursor-pointer rounded-md focus:outline-none focus:ring focus:ring-green-400 transition px-4 py-1.5 font-medium text-sm bg-[#2A2A2A] text-white border border-[#4B5563] w-full text-left flex justify-between items-center">
                    <span id="selectedMarketText">Select Market</span>
                    <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                      <path d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"/>
                    </svg>
                  </button>
                  
                  <!-- Hidden standard select for compatibility with existing code -->
                  <select id="marketSelect" class="hidden">
                    <option value="S">Sonic</option>
                    <option value="ETH">ETH</option>
                  </select>
                  
                  <!-- Custom dropdown with market details -->
                  <div id="marketDropdownList" class="absolute z-10 w-80 mt-1 bg-[#2A2A2A] border border-[#4B5563] rounded-md shadow-lg max-h-96 overflow-y-auto hidden">
                    <!-- Search box for markets -->
                    <div class="sticky top-0 p-2 bg-[#2A2A2A] border-b border-[#4B5563] z-20">
                      <input id="marketSearchInput" type="text" placeholder="Search markets..." 
                             class="w-full px-3 py-2 bg-[#3A3A3A] text-white rounded-md border border-[#4B5563] focus:outline-none focus:ring focus:ring-green-400 text-sm">
                      
                      <!-- Sort options -->
                      <div class="flex justify-between mt-2 text-xs text-gray-400">
                        <span>Sort by:</span>
                        <div class="flex space-x-2">
                          <button id="sortByName" class="hover:text-green-400">Name</button>
                          <button id="sortByLiquidity" class="hover:text-green-400 sort-active">Liquidity</button>
                          <button id="sortByVolume" class="hover:text-green-400">Volume</button>
                        </div>
                      </div>
                    </div>
                    <!-- Dropdown items will be added here by JavaScript -->
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Right side: Product type toggle -->
          <div id="productTypeToggleContainer">
            <div class="threeway-toggle" id="productTypeToggle">
              <button id="toggleSpot" class="disabled opacity-50 cursor-not-allowed">Spot</button>
              <button id="toggleOptions" class="active">Options</button>
                <button id="togglePerp">Perps</button>
            </div>
          </div>
        </div>
          
          <!-- Zoom Presets (visible only in Options mode) -->
          <div class="flex items-center mb-2" id="zoomContainer">
            <button class="zoom-preset-btn" data-preset="full">Full</button>
            <button class="zoom-preset-btn" data-preset="50">50%</button>
            <button class="zoom-preset-btn" data-preset="25">25%</button>
            <button class="zoom-preset-btn" data-preset="10">10%</button>
            </div>
          
          <!-- Chart Container -->
          <div id="topChartContainer"></div>
        </div>
        
        <!-- Right Side Panel (Trading Controls) - Similar to Binance UI -->
        <div class="w-80 relative bg-gray-200 dark:bg-[#1F1F1F] rounded-lg shadow-3d p-4">
          <h2 class="text-white font-bold text-lg mb-4 border-b border-gray-700 pb-2">Trading Controls</h2>
          
          <!-- Options Controls -->
          <div id="tradeControlsOptions">
            <div class="mb-4">
              <label for="expirySelect" class="control-label mb-1 block">Expiry</label>
              <div class="relative inline-block w-full">
                <select id="expirySelect" class="appearance-none cursor-pointer rounded-md focus:outline-none focus:ring focus:ring-green-400 transition px-4 py-1.5 font-medium text-sm bg-[#2A2A2A] text-white border border-[#4B5563] w-full">
                <option value="3600">1h</option>
                <option value="7200">2h</option>
                <option value="21600">6h</option>
                <option value="43200">12h</option>
                <option value="86400" selected>24h</option>
                <option value="604800">1w</option>
              </select>
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
                  <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                    <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" />
                  </svg>
            </div>
              </div>
            </div>
            
            <!-- Option Type Toggle (replaces dropdown) -->
            <div class="mb-4">
              <label class="control-label mb-1 block">Option Type</label>
              <div class="option-type-toggle w-full flex rounded-md overflow-hidden border border-[#4B5563]">
                <button id="optionTypeCall" class="flex-1 py-2 px-1 bg-[#2A2A2A] text-white hover:bg-[#3A3A3A] transition flex flex-col items-center" data-option-type="call">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 8L12 2L6 8" stroke="#0FFF95" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12 2L12 22" stroke="#0FFF95" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                  <span class="text-xs">Long</span>
                </button>
                <button id="optionTypeStrangle" class="flex-1 py-2 px-1 bg-[#2A2A2A] text-white hover:bg-[#3A3A3A] transition flex flex-col items-center active" data-option-type="strangle">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M6 8L12 2L18 8" stroke="#0FFF95" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M6 16L12 22L18 16" stroke="#FF4B4B" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12 2L12 22" stroke="#FFFFFF" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                  <span class="text-xs">Both</span>
                </button>
                <button id="optionTypePut" class="flex-1 py-2 px-1 bg-[#2A2A2A] text-white hover:bg-[#3A3A3A] transition flex flex-col items-center" data-option-type="put">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 mb-1" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M6 16L12 22L18 16" stroke="#FF4B4B" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12 22L12 2" stroke="#FF4B4B" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                  <span class="text-xs">Short</span>
                </button>
              </div>
              <!-- Keep the original select for JavaScript compatibility but hide it -->
              <select id="optionType" class="hidden">
                <option value="call">Call</option>
                <option value="put">Put</option>
                <option value="strangle" selected>Strangle</option>
              </select>
            </div>
            
          <!-- Dynamic Option Controls -->
            <div id="optionDynamicControls" style="display: none;" class="mt-4">
            <!-- Call Controls -->
              <div id="callControls" style="display: none;" class="mb-4">
                <div class="text-white mb-2 font-medium">Calls</div>
                <div class="flex space-x-2">
                  <div class="flex-1">
                    <div class="input-wrapper">
                      <span class="arrow-indicator arrow-left">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <line x1="19" y1="12" x2="5" y2="12"></line>
                          <polyline points="12 19 5 12 12 5"></polyline>
                        </svg>
                      </span>
                      <input type="number" id="callMinInput" placeholder="Min Strike" class="neumorphic-sunken rounded-md text-xs focus:outline-none focus:ring focus:ring-green-400 transition w-full compact-input input-with-left-arrow" step="0.0001" />
                    </div>
                  </div>
                  <div class="flex-1">
                    <div class="input-wrapper">
                      <input type="number" id="callMaxInput" placeholder="Max Strike" class="neumorphic-sunken rounded-md text-xs focus:outline-none focus:ring focus:ring-green-400 transition w-full compact-input input-with-right-arrow" step="0.0001" />
                      <span class="arrow-indicator arrow-right">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <line x1="5" y1="12" x2="19" y2="12"></line>
                          <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                      </span>
                    </div>
                  </div>
                </div>
                <div class="mt-4">
                  <div class="available-liquidity" id="callAvailableLiquidity">Available: $0</div>
                  <div class="amount-input-wrapper">
                    <input type="number" id="callAmountInput" placeholder="Amount" class="neumorphic-sunken rounded-md text-xs focus:outline-none focus:ring focus:ring-green-400 transition w-full compact-input amount-input" step="0.01" min="0" />
                    <button id="callMaxButton" class="max-button">MAX</button>
                  </div>
                  <input type="range" id="tradeAmountCall" min="0" max="100" value="0" step="1" class="slider w-full">
                </div>
              </div>
              
            <!-- Put Controls -->
              <div id="putControls" style="display: none;" class="mb-4">
                <div class="text-white mb-2 font-medium">Puts</div>
                <div class="flex space-x-2">
                  <div class="flex-1">
                    <div class="input-wrapper">
                      <span class="arrow-indicator arrow-left">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <line x1="19" y1="12" x2="5" y2="12"></line>
                          <polyline points="12 19 5 12 12 5"></polyline>
                        </svg>
                      </span>
                      <input type="number" id="putMaxInput" placeholder="Min Strike" class="neumorphic-sunken rounded-md text-xs focus:outline-none focus:ring focus:ring-green-400 transition w-full compact-input input-with-left-arrow" step="0.0001" />
                    </div>
                  </div>
                  <div class="flex-1">
                    <div class="input-wrapper">
                      <input type="number" id="putMinInput" placeholder="Max Strike" class="neumorphic-sunken rounded-md text-xs focus:outline-none focus:ring focus:ring-green-400 transition w-full compact-input input-with-right-arrow" step="0.0001" />
                      <span class="arrow-indicator arrow-right">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                          <line x1="5" y1="12" x2="19" y2="12"></line>
                          <polyline points="12 5 19 12 12 19"></polyline>
                        </svg>
                      </span>
                    </div>
                  </div>
                </div>
                <div class="mt-4">
                  <div class="available-liquidity" id="putAvailableLiquidity">Available: $0</div>
                  <div class="amount-input-wrapper">
                    <input type="number" id="putAmountInput" placeholder="Amount" class="neumorphic-sunken rounded-md text-xs focus:outline-none focus:ring focus:ring-green-400 transition w-full compact-input amount-input" step="0.01" min="0" />
                    <button id="putMaxButton" class="max-button">MAX</button>
                  </div>
                  <input type="range" id="tradeAmountPut" min="0" max="100" value="0" step="1" class="slider w-full">
                </div>
              </div>
              
              <!-- Submit Button (Options) -->
              <div class="mt-4">
                <button id="submitBtn" class="btn-3d py-2 px-4 text-base font-medium w-full">Submit</button>
            </div>
          </div>
          </div>
          
          <!-- Perp Controls -->
          <div id="tradeControlsPerp" style="display: none;">
            <div class="mb-4">
              <label for="marketSelectPerp" class="control-label mb-1 block">Market</label>
              <div class="relative inline-block w-full">
                <select id="marketSelectPerp" class="appearance-none cursor-pointer rounded-md focus:outline-none focus:ring focus:ring-green-400 transition px-4 py-1.5 font-medium text-sm bg-[#2A2A2A] text-white border border-[#4B5563] w-full">
                <option value="S">Sonic</option>
                <option value="ETH">ETH</option>
              </select>
                <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-white">
                  <svg class="fill-current h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20">
                    <path d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" />
                  </svg>
            </div>
              </div>
            </div>
            <div class="mb-4">
              <label for="tradeAmountPerp" class="control-label">Amount</label>
              <input type="number" id="tradeAmountPerp" class="neumorphic-sunken rounded-md text-base focus:outline-none focus:ring focus:ring-green-400 transition w-full" step="any" value="1" />
            </div>
            <div id="perpPositionToggle" class="mb-4">
              <label class="control-label mb-1 block">Position</label>
              <div class="threeway-toggle w-full">
                <button id="toggleLong" class="active">Long</button>
                <button id="toggleShort">Short</button>
              </div>
            </div>
            <div class="mt-4">
              <button id="submitBtnPerp" class="btn-3d py-2 px-4 text-base font-medium w-full">Submit</button>
            </div>
          </div>
          </div>
      </div>
    </section>
    
    <!-- Last Updated & Refresh -->
    <div class="max-w-7xl mx-auto px-4 flex justify-end mt-2 items-center space-x-2">
      <span id="lastUpdated" class="text-neonGreen text-sm">Last Updated: -- secs ago</span>
      <button id="refreshButton" class="text-neonGreen text-xl focus:outline-none" title="Refresh Data">â†»</button>
    </div>
    
    <!-- Modal Popup for Table & PnL -->
    <div id="modalPopup" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2 class="text-white">Trade Summary</h2>
          <button id="modalClose" class="modal-close">&times;</button>
        </div>
        <div class="modal-tabs">
          <button id="tabTable" class="modal-tab active">Table</button>
          <button id="tabPnL" class="modal-tab">PnL</button>
        </div>
        <div class="modal-body">
          <div id="modalTable"></div>
          <div id="modalPnL" class="hidden"></div>
        </div>
      </div>
    </div>
    
    <script>
      /******************************************************
       * GLOBAL VARIABLES & CONFIG
       ******************************************************/
      let totalLiquidityChartInstance = null;
      let pnlChartInstance = null;
      let tradeData = {};
      let currentProductType = "options"; // "options" or "perp"
      let useLogScale = false;
      let spotPriceGlobal = 0;
      let lastUpdateTime = Date.now();
      let globalMinTick = 0;
      let globalMaxTick = 1;
      let zoomPreset = null;
      
      window.liquidityLog = [];
      window.processedLiquidityData = [];
      
      const marketConfig = {
        S: {
          optionMarket: "0x342e4068bA07bbCcBDDE503b2451FAa3D3C0278B",
          spotApi: "https://api.stryke.xyz/uniswap-prices/mark-price?chainId=146&ticker=WS/USDC.e"
        },
        ETH: {
          optionMarket: "0x9d3828e89Fadc4DEc77758988b388435Fe0f8DCa",
          spotApi: "https://api.stryke.xyz/uniswap-prices/mark-price?chainId=146&ticker=WETH/USDC.e"
        }
      };
      const intradayHook = "0x78d96C07B16d8f911c4cD14EE10601921E4fb8aF";
      const weeklyHook = "0xf6314300b42B7D88c153348921a95d3CA95E74Bd";
      
      /******************************************************
       * DRAGGABLE RANGE SELECTOR PLUGIN
       ******************************************************/
      const draggableRangePlugin = {
        id: "draggableRangePlugin",
        draggingSelector: null,
        initialDragDistance: 0,
        lastX: 0,
        afterInit(chart, options) {
          // Add mouse event listeners
          chart.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e, chart));
          chart.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e, chart));
          chart.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e, chart));
          chart.canvas.addEventListener('mouseleave', (e) => this.handleMouseUp(e, chart));
          
          // Add global mouseup handler to ensure release even if outside canvas
          window.addEventListener('mouseup', () => this.handleMouseUp(null, chart));
          
          // Initial state
          this.draggingSelector = null;
          this.initialDragDistance = 0;
        },
        updateCursorStyle(x, chart) {
          if (!this.draggingSelector) {
            const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
            const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
            const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
            const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
            
            const xScale = chart.scales.x;
            const callMinPixel = xScale.getPixelForValue(callMin);
            const callMaxPixel = xScale.getPixelForValue(callMax);
            const putMinPixel = xScale.getPixelForValue(putMin);
            const putMaxPixel = xScale.getPixelForValue(putMax);
            
            const threshold = 10; // pixels
            
            // Check if mouse is near a selector
            if (Math.abs(x - callMinPixel) < threshold || Math.abs(x - callMaxPixel) < threshold ||
                Math.abs(x - putMinPixel) < threshold || Math.abs(x - putMaxPixel) < threshold) {
              chart.canvas.style.cursor = 'ew-resize';
            } 
            // Check if mouse is between selectors
            else if ((x > callMinPixel && x < callMaxPixel) || (x > putMinPixel && x < putMaxPixel)) {
              chart.canvas.style.cursor = 'grab';
            }
            else {
              chart.canvas.style.cursor = 'default';
            }
          } else if (this.draggingSelector === "callBoth" || this.draggingSelector === "putBoth") {
            chart.canvas.style.cursor = 'grabbing';
          }
        },
        handleMouseDown(e, chart) {
          // Get mouse coordinates
          const rect = chart.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          
          // Get current selector values in pixels
          const xScale = chart.scales.x;
          const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
          const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
          const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
          const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
          
          const callMinPixel = xScale.getPixelForValue(callMin);
          const callMaxPixel = xScale.getPixelForValue(callMax);
          const putMinPixel = xScale.getPixelForValue(putMin);
          const putMaxPixel = xScale.getPixelForValue(putMax);
          
          const threshold = 10; // pixels
          
          // Check if click is near a selector
          if (Math.abs(x - callMinPixel) < threshold) {
            this.draggingSelector = "callMin";
            chart.canvas.style.cursor = 'ew-resize';
          } else if (Math.abs(x - callMaxPixel) < threshold) {
            this.draggingSelector = "callMax";
            chart.canvas.style.cursor = 'ew-resize';
          } else if (Math.abs(x - putMinPixel) < threshold) {
            this.draggingSelector = "putMin";
            chart.canvas.style.cursor = 'ew-resize';
          } else if (Math.abs(x - putMaxPixel) < threshold) {
            this.draggingSelector = "putMax";
            chart.canvas.style.cursor = 'ew-resize';
          } 
          // Check if click is between selectors (for dragging both)
          else if (x > callMinPixel && x < callMaxPixel) {
            this.draggingSelector = "callBoth";
            chart.canvas.style.cursor = 'grabbing';
            
            // Store the width of the selection and offsets from mouse to edges
            this.callMinOffset = x - callMinPixel;
            this.callMaxOffset = callMaxPixel - x;
          } else if (x > putMinPixel && x < putMaxPixel) {
            this.draggingSelector = "putBoth";
            chart.canvas.style.cursor = 'grabbing';
            
            // Store the width of the selection and offsets from mouse to edges
            this.putMinOffset = x - putMinPixel;
            this.putMaxOffset = putMaxPixel - x;
          }
        },
        handleMouseMove(e, chart) {
          // Get mouse coordinates
          const rect = chart.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          
          // Update cursor style if not dragging
          if (!this.draggingSelector) {
            this.updateCursorStyle(x, chart);
            return;
          }
          
          const xScale = chart.scales.x;
          const xVal = xScale.getValueForPixel(x);
          
          // Set newVal based on position
          let newVal = Math.round(xVal * 10000) / 10000;
          
          // Handle different selectors
          if (this.draggingSelector === "callMin") {
            // Add constraint: call min cannot go below mark price
            newVal = Math.max(newVal, spotPriceGlobal);
            const currentCallMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
            newVal = Math.min(newVal, currentCallMax - 0.0001);
            document.getElementById("callMinInput").value = newVal.toFixed(4);
            
            // Force chart update immediately without heavy calculations
            chart.update('none');
            
            // Update colors only when dragging a call selector
            updateChartColors();
            
            // Update available liquidity display
            const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
            const callMax = parseFloat(document.getElementById("callMaxInput").value) || spotPriceGlobal;
            const availableLiquidity = calculateAvailableLiquidity(callMin, callMax, spotPriceGlobal);
            document.getElementById("callAvailableLiquidity").textContent = `Available: $${availableLiquidity.toFixed(2)}`;
          }
          else if (this.draggingSelector === "callMax") {
            const currentCallMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
            newVal = Math.max(newVal, currentCallMin + 0.0001);
            document.getElementById("callMaxInput").value = newVal.toFixed(4);
            
            // Force chart update immediately without heavy calculations
            chart.update('none');
            
            // Update colors only when dragging a call selector
            updateChartColors();
            
            // Update available liquidity display
            const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
            const callMax = parseFloat(document.getElementById("callMaxInput").value) || spotPriceGlobal;
            const availableLiquidity = calculateAvailableLiquidity(callMin, callMax, spotPriceGlobal);
            document.getElementById("callAvailableLiquidity").textContent = `Available: $${availableLiquidity.toFixed(2)}`;
          }
          else if (this.draggingSelector === "callBoth") {
            // Calculate new positions directly based on mouse position and stored offsets
            const callMinPixel = x - this.callMinOffset;
            const callMaxPixel = x + this.callMaxOffset;
            
            // Convert pixels to values
            let callMin = xScale.getValueForPixel(callMinPixel);
            let callMax = xScale.getValueForPixel(callMaxPixel);
            
            // Apply constraints: call min cannot go below mark price
            if (callMin < spotPriceGlobal) {
              // Calculate the pixel adjustment needed
              const newCallMinPixel = xScale.getPixelForValue(spotPriceGlobal);
              const pixelAdjustment = newCallMinPixel - callMinPixel;
              
              // Adjust both pixels
              callMin = spotPriceGlobal;
              callMax = xScale.getValueForPixel(callMaxPixel + pixelAdjustment);
            }
            
            // Update inputs
            document.getElementById("callMinInput").value = callMin.toFixed(4);
            document.getElementById("callMaxInput").value = callMax.toFixed(4);
            
            // Force chart update
            chart.update('none');
            
            // Update colors during drag to show real-time changes
            updateChartColors();
            
            // Update available liquidity display
            const availableLiquidity = calculateAvailableLiquidity(callMin, callMax, spotPriceGlobal);
            document.getElementById("callAvailableLiquidity").textContent = `Available: $${availableLiquidity.toFixed(2)}`;
          }
          else if (this.draggingSelector === "putMax") {
            // Add constraint: put max cannot go above mark price
            newVal = Math.min(newVal, spotPriceGlobal);
            const currentPutMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
            newVal = Math.max(newVal, currentPutMin + 0.0001);
            document.getElementById("putMaxInput").value = newVal.toFixed(4);
            
            // Force chart update immediately without heavy calculations
            chart.update('none');
            
            // Update colors during drag to show real-time changes
            updateChartColors();
          }
          else if (this.draggingSelector === "putMin") {
            const currentPutMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
            newVal = Math.min(newVal, currentPutMax - 0.0001);
            document.getElementById("putMinInput").value = newVal.toFixed(4);
            
            // Force chart update immediately without heavy calculations
            chart.update('none');
            
            // Update colors during drag to show real-time changes
            updateChartColors();
          }
          else if (this.draggingSelector === "putBoth") {
            // Calculate new positions directly based on mouse position and stored offsets
            const putMinPixel = x - this.putMinOffset;
            const putMaxPixel = x + this.putMaxOffset;
            
            // Convert pixels to values
            let putMin = xScale.getValueForPixel(putMinPixel);
            let putMax = xScale.getValueForPixel(putMaxPixel);
            
            // Apply constraints: put max cannot go above mark price
            if (putMax > spotPriceGlobal) {
              // Calculate the pixel adjustment needed
              const newPutMaxPixel = xScale.getPixelForValue(spotPriceGlobal);
              const pixelAdjustment = putMaxPixel - newPutMaxPixel;
              
              // Adjust both pixels
              putMax = spotPriceGlobal;
              putMin = xScale.getValueForPixel(putMinPixel - pixelAdjustment);
            }
            
            // Update inputs
            document.getElementById("putMinInput").value = putMin.toFixed(4);
            document.getElementById("putMaxInput").value = putMax.toFixed(4);
            
            // Force chart update
            chart.update('none');
            
            // Update colors during drag to show real-time changes
            updateChartColors();
          }
        },
        handleMouseUp(e, chart) {
          // Save current selector before resetting
          const currentSelector = this.draggingSelector;
          
          // Reset dragging state immediately
          this.draggingSelector = null;
          chart.canvas.style.cursor = 'default';
          
          // Final update when mouse is released
          chart.update();
          
          // We no longer need a separate update for put selectors
          // since we're already updating during mouse movement
          // if (currentSelector === "putMin" || currentSelector === "putMax" || currentSelector === "putBoth") {
          //   updateChartColors();
          // }
        },
        getRelativePosition(e, chart) {
          const rect = chart.canvas.getBoundingClientRect();
          return { x: e.clientX - rect.left, y: e.clientY - rect.top };
        },
        afterDraw(chart) {
          if (!chart.scales.x) return;
          const { ctx, chartArea, scales: { x } } = chart;
          ctx.save();
          
          // Get selector values based on option type
          const optType = document.getElementById("optionType").value;
          let selectedRanges = [];
          
          if (optType === "call" || optType === "strangle") {
            const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
            const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
            selectedRanges.push({
              min: callMin,
              max: callMax,
              minX: x.getPixelForValue(callMin),
              maxX: x.getPixelForValue(callMax)
            });
          }
          
          if (optType === "put" || optType === "strangle") {
            const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
            const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
            selectedRanges.push({
              min: putMin,
              max: putMax,
              minX: x.getPixelForValue(putMin),
              maxX: x.getPixelForValue(putMax)
            });
          }
          
          // Draw a light grey overlay ONLY outside the selected ranges
          // Use a lighter, more transparent grey for subtlety
          ctx.fillStyle = "rgba(200, 200, 200, 0.25)";
          
          // First, draw left overlay (area to the left of the first range)
          if (selectedRanges.length > 0) {
            // Sort ranges by minX to handle them from left to right
            selectedRanges.sort((a, b) => a.minX - b.minX);
            
            // Area to the left of the first range
            if (selectedRanges[0].minX > chartArea.left) {
              ctx.fillRect(
                chartArea.left, 
                chartArea.top, 
                selectedRanges[0].minX - chartArea.left, 
                chartArea.height
              );
            }
            
            // Areas between ranges (if there are multiple)
            for (let i = 0; i < selectedRanges.length - 1; i++) {
              const rightOfCurrentRange = selectedRanges[i].maxX;
              const leftOfNextRange = selectedRanges[i + 1].minX;
              
              if (leftOfNextRange > rightOfCurrentRange) {
                ctx.fillRect(
                  rightOfCurrentRange,
                  chartArea.top,
                  leftOfNextRange - rightOfCurrentRange,
                  chartArea.height
                );
              }
            }
            
            // Area to the right of the last range
            const lastRange = selectedRanges[selectedRanges.length - 1];
            if (lastRange.maxX < chartArea.right) {
              ctx.fillRect(
                lastRange.maxX,
                chartArea.top,
                chartArea.right - lastRange.maxX,
                chartArea.height
              );
            }
          }
          
          // Draw the selector lines and circles
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; // Transparent white (was "red")
          ctx.lineWidth = 2;
          
          if (optType === "call" || optType === "strangle") {
            const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
            const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
            const callMinX = x.getPixelForValue(callMin);
            const callMaxX = x.getPixelForValue(callMax);
            ctx.beginPath();
            ctx.moveTo(callMinX, chartArea.top);
            ctx.lineTo(callMinX, chartArea.bottom);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(callMinX, chartArea.bottom - 5, 4, 0, 2 * Math.PI);
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; // Transparent white (was "white")
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(callMaxX, chartArea.top);
            ctx.lineTo(callMaxX, chartArea.bottom);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(callMaxX, chartArea.bottom - 5, 4, 0, 2 * Math.PI);
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; // Transparent white (was "white")
            ctx.fill();
            const midCallX = (callMinX + callMaxX) / 2;
            ctx.font = "bold 14px sans-serif";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            let callLiquidity = window.processedLiquidityData.filter(p => p.strike >= callMin && p.strike <= callMax)
                                 .reduce((sum, p) => sum + p.avail, 0);
            // Get the selected percentage from the slider
            const callSliderValue = parseInt(document.getElementById("tradeAmountCall").value) || 0;
            const selectedCallLiquidity = callLiquidity * (callSliderValue / 100);
            ctx.fillText("$" + formatNumber(selectedCallLiquidity) + " / $" + formatNumber(callLiquidity), midCallX, chartArea.top + 14);
          }
          if (optType === "put" || optType === "strangle") {
            const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
            const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
            const putMaxX = x.getPixelForValue(putMax);
            const putMinX = x.getPixelForValue(putMin);
            ctx.beginPath();
            ctx.moveTo(putMaxX, chartArea.top);
            ctx.lineTo(putMaxX, chartArea.bottom);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(putMaxX, chartArea.bottom - 5, 4, 0, 2 * Math.PI);
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; // Transparent white (was "white")
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(putMinX, chartArea.top);
            ctx.lineTo(putMinX, chartArea.bottom);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(putMinX, chartArea.bottom - 5, 4, 0, 2 * Math.PI);
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; // Transparent white (was "white")
            ctx.fill();
            const midPutX = (putMinX + putMaxX) / 2;
            ctx.font = "bold 14px sans-serif";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            let putLiquidity = window.processedLiquidityData.filter(p => p.strike >= putMin && p.strike <= putMax)
                                 .reduce((sum, p) => sum + p.avail, 0);
            // Get the selected percentage from the slider
            const putSliderValue = parseInt(document.getElementById("tradeAmountPut").value) || 0;
            const selectedPutLiquidity = putLiquidity * (putSliderValue / 100);
            ctx.fillText("$" + formatNumber(selectedPutLiquidity) + " / $" + formatNumber(putLiquidity), midPutX, chartArea.top + 14);
          }
          ctx.restore();
        }
      };
      
      /******************************************************
       * UTILITY FUNCTIONS
       ******************************************************/
      function destroyTotalLiquidityChart() {
        if (totalLiquidityChartInstance instanceof Chart) {
          totalLiquidityChartInstance.destroy();
        }
      }
      function destroyPnLChart() {
        if (pnlChartInstance instanceof Chart) {
          pnlChartInstance.destroy();
        }
      }
      function formatNumber(num) {
        return parseFloat(num).toLocaleString(undefined, { maximumFractionDigits: 2 });
      }
      
      /******************************************************
       * ZOOM PRESET FUNCTIONS (Options only)
       ******************************************************/
      function setZoomPreset(preset) {
        if (currentProductType === "options") {
          if (preset === "full") {
            zoomPreset = null;
      
            zoomPreset = { min: spotPriceGlobal * 0.5, max: spotPriceGlobal * 1.5 };
          } else if (preset === "25") {
            zoomPreset = { min: spotPriceGlobal * 0.75, max: spotPriceGlobal * 1.25 };
          } else if (preset === "10") {
            zoomPreset = { min: spotPriceGlobal * 0.90, max: spotPriceGlobal * 1.10 };
          }
          
          // Reset amount sliders to 0%
          document.getElementById("tradeAmountCall").value = 0;
          document.getElementById("callAmountInput").value = "0.00";
          document.getElementById("callAvailableLiquidity").textContent = "Available: $0";
          document.getElementById("tradeAmountPut").value = 0;
          document.getElementById("putAmountInput").value = "0.00";
          document.getElementById("putAvailableLiquidity").textContent = "Available: $0";
          
          // Reset selectors to specified ranges based on zoom level and option type
          const optType = document.getElementById("optionType").value;
          
          if (preset === "full") {
            // Full: Call selectors min at mark price, max at last tick
            // Put selectors max at mark price, min at first tick
            if (optType === "call" || optType === "strangle") {
              // Ensure call min is at least at mark price
              document.getElementById("callMinInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("callMaxInput").value = globalMaxTick.toFixed(4);
            }
            if (optType === "put" || optType === "strangle") {
              // Ensure put max is at most at mark price
              document.getElementById("putMaxInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("putMinInput").value = globalMinTick.toFixed(4);
            }
          } else if (preset === "50") {
            // 50%: 0% to 20% from mark price
            if (optType === "call" || optType === "strangle") {
              // Ensure call min is at least at mark price
              document.getElementById("callMinInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("callMaxInput").value = (spotPriceGlobal * 1.20).toFixed(4);
            }
            if (optType === "put" || optType === "strangle") {
              // Ensure put max is at most at mark price
              document.getElementById("putMaxInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("putMinInput").value = (spotPriceGlobal * 0.80).toFixed(4);
            }
          } else if (preset === "25") {
            // 25%: 0% to 10% from mark price
            if (optType === "call" || optType === "strangle") {
              // Ensure call min is at least at mark price
              document.getElementById("callMinInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("callMaxInput").value = (spotPriceGlobal * 1.10).toFixed(4);
            }
            if (optType === "put" || optType === "strangle") {
              // Ensure put max is at most at mark price
              document.getElementById("putMaxInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("putMinInput").value = (spotPriceGlobal * 0.90).toFixed(4);
            }
          } else if (preset === "10") {
            // 10%: 0% to 5% from mark price
            if (optType === "call" || optType === "strangle") {
              // Ensure call min is at least at mark price
              document.getElementById("callMinInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("callMaxInput").value = (spotPriceGlobal * 1.05).toFixed(4);
            }
            if (optType === "put" || optType === "strangle") {
              // Ensure put max is at most at mark price
              document.getElementById("putMaxInput").value = spotPriceGlobal.toFixed(4);
              document.getElementById("putMinInput").value = (spotPriceGlobal * 0.95).toFixed(4);
            }
          }
          
          // Update the chart colors to reflect the new selector ranges
          updateChartColors();
        }
        updateTopPanelView();
        document.querySelectorAll(".zoom-preset-btn").forEach(btn => btn.classList.remove("active"));
        const btn = document.querySelector(`.zoom-preset-btn[data-preset="${preset}"]`);
        if (btn) btn.classList.add("active");
      }
      
      // Add event listeners for zoom preset buttons
      document.querySelectorAll('.zoom-preset-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const preset = btn.getAttribute('data-preset');
          setZoomPreset(preset);
        });
      });
      
      /******************************************************
       * UPDATE CHART COLORS (Smooth, realâ€‘time update)
       ******************************************************/
      function updateChartColors() {
        console.log("updateChartColors called");
        const optionType = document.getElementById("optionType").value;
        const allData = window.processedLiquidityData;
        console.log("Data length:", allData.length);
        
        let utilized = new Array(allData.length).fill(0);
        let remaining = new Array(allData.length).fill(0);
        
        // Process based on option type
        if (optionType === "call") {
          const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
          const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
          const slider = parseInt(document.getElementById("tradeAmountCall").value);
          console.log("Call slider value:", slider);
          
          let callRange = allData.filter(p => p.strike >= callMin && p.strike <= callMax);
          console.log("Strikes in range:", callRange.length);
          
          let total = callRange.reduce((sum, p) => sum + p.avail, 0);
          let target = total * (slider / 100);
          console.log("Target utilization:", target, "out of", total);
          
          // Update the available liquidity display
          document.getElementById("callAvailableLiquidity").textContent = `Available: $${formatNumber(total)}`;
          
          // Update the amount input field if it doesn't have focus
          if (document.activeElement !== document.getElementById("callAmountInput")) {
            document.getElementById("callAmountInput").value = formatNumberForInput(target);
          }
          
          let cumulative = 0;
          for (let i = 0; i < allData.length; i++) {
            const p = allData[i];
            if (p.strike >= callMin && p.strike <= callMax) {
              if (cumulative < target) {
                let use = Math.min(p.avail, target - cumulative);
                utilized[i] = use;
                remaining[i] = p.avail - use;
                cumulative += use;
              } else {
                utilized[i] = 0;
                remaining[i] = p.avail;
              }
            } else {
              utilized[i] = 0;
              remaining[i] = p.avail;
            }
          }
          console.log("Cumulative utilized:", cumulative);
        } else if (optionType === "put") {
          const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
          const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
          const slider = parseInt(document.getElementById("tradeAmountPut").value);
          // Get all the strikes within our range
          let putRange = allData.filter(p => p.strike >= putMin && p.strike <= putMax);
          // Sort from highest to lowest strike (right to left on chart)
          putRange.sort((a, b) => b.strike - a.strike);
          
          let total = putRange.reduce((sum, p) => sum + p.avail, 0);
          let target = total * (slider / 100);
          
          // Update the available liquidity display
          document.getElementById("putAvailableLiquidity").textContent = `Available: $${formatNumber(total)}`;
          
          // Update the amount input field if it doesn't have focus
          if (document.activeElement !== document.getElementById("putAmountInput")) {
            document.getElementById("putAmountInput").value = formatNumberForInput(target);
          }
          
          let cumulative = 0;
          
          // Create a map to track which strikes have liquidity utilized
          let strikeMap = {};
          
          // Process liquidity starting from highest strike (closest to putMax/strike price)
          for (let tick of putRange) {
            strikeMap[tick.strike] = {
              utilized: 0,
              remaining: tick.avail
            };
            
            if (cumulative < target) {
              let use = Math.min(tick.avail, target - cumulative);
              strikeMap[tick.strike].utilized = use;
              strikeMap[tick.strike].remaining = tick.avail - use;
              cumulative += use;
            }
          }
          
          // Now apply the utilized/remaining values to our main arrays
          for (let i = 0; i < allData.length; i++) {
            const tick = allData[i];
            if (strikeMap[tick.strike]) {
              utilized[i] = strikeMap[tick.strike].utilized;
              remaining[i] = strikeMap[tick.strike].remaining;
            } else {
              utilized[i] = 0;
              remaining[i] = tick.avail;
            }
          }
          
          // Remove reference to non-existent element
          // document.getElementById("putLiquidityDisplay").innerText =
          //  slider + "% ($" + formatNumber(target) + " / $" + formatNumber(total) + ")";
        } else if (optionType === "strangle") {
          // Call side (fills left to right)
          const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
          const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
          const callSlider = parseInt(document.getElementById("tradeAmountCall").value);
          let callRange = allData.filter(p => p.strike >= callMin && p.strike <= callMax);
          let callTotal = callRange.reduce((sum, p) => sum + p.avail, 0);
          let callTarget = callTotal * (callSlider / 100);
          
          // Put side (fills right to left, from strike price downward)
          const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
          const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
          const putSlider = parseInt(document.getElementById("tradeAmountPut").value);
          let putRange = allData.filter(p => p.strike >= putMin && p.strike <= putMax)
                        .sort((a, b) => b.strike - a.strike); // Sort from highest to lowest
          let putTotal = putRange.reduce((sum, p) => sum + p.avail, 0);
          let putTarget = putTotal * (putSlider / 100);
          
          // Track utilized liquidity by strike for both call and put
          let callUtilized = {};
          let putUtilized = {};
          
          // Process call liquidity (left to right)
          let callCumulative = 0;
          for (let p of callRange) {
            if (callCumulative < callTarget) {
              let use = Math.min(p.avail, callTarget - callCumulative);
              callUtilized[p.strike] = use;
              callCumulative += use;
            } else {
              callUtilized[p.strike] = 0;
            }
          }
          
          // Process put liquidity (right to left, high to low strikes)
          let putCumulative = 0;
          for (let p of putRange) {
            if (putCumulative < putTarget) {
              let use = Math.min(p.avail, putTarget - putCumulative);
              putUtilized[p.strike] = use;
              putCumulative += use;
            } else {
              putUtilized[p.strike] = 0;
            }
          }
          
          // Apply the utilized and remaining values
          for (let i = 0; i < allData.length; i++) {
            const p = allData[i];
            if (p.strike >= callMin && p.strike <= callMax) {
              utilized[i] = callUtilized[p.strike] || 0;
              remaining[i] = p.avail - utilized[i];
            } else if (p.strike >= putMin && p.strike <= putMax) {
              utilized[i] = putUtilized[p.strike] || 0;
              remaining[i] = p.avail - utilized[i];
              } else {
                utilized[i] = 0;
                remaining[i] = p.avail;
              }
            }
          
          // Remove references to non-existent elements
          // document.getElementById("callLiquidityDisplay").innerText =
          //  callSlider + "% ($" + formatNumber(callTarget) + " / $" + formatNumber(callTotal) + ")";
          // document.getElementById("putLiquidityDisplay").innerText =
          //  putSlider + "% ($" + formatNumber(putTarget) + " / $" + formatNumber(putTotal) + ")";
          
          // Update the available liquidity displays for strangle
          document.getElementById("callAvailableLiquidity").textContent = `Available: $${formatNumber(callTotal)}`;
          document.getElementById("putAvailableLiquidity").textContent = `Available: $${formatNumber(putTotal)}`;
          
          // Update the amount input fields if they don't have focus
          if (document.activeElement !== document.getElementById("callAmountInput")) {
            document.getElementById("callAmountInput").value = formatNumberForInput(callTarget);
          }
          if (document.activeElement !== document.getElementById("putAmountInput")) {
            document.getElementById("putAmountInput").value = formatNumberForInput(putTarget);
          }
        }
        
        // Make sure we have data to update the chart with
        if (totalLiquidityChartInstance && allData.length > 0) {
          console.log("Updating chart data");
          
          const utilizedTicks = window.processedLiquidityData.map((p, i) => ({ x: p.strike, y: utilized[i] }));
          const remainingTicks = window.processedLiquidityData.map((p, i) => ({ x: p.strike, y: remaining[i] }));
          
          // Ensure we're working with valid data
          console.log("Utilized ticks count:", utilizedTicks.length);
          console.log("Remaining ticks count:", remainingTicks.length);
          console.log("First utilized tick:", utilizedTicks.length > 0 ? JSON.stringify(utilizedTicks[0]) : "none");
          
          // Update both utilized and remaining datasets
          if (totalLiquidityChartInstance.data.datasets.length >= 2) {
          totalLiquidityChartInstance.data.datasets[0].data = utilizedTicks;
          totalLiquidityChartInstance.data.datasets[1].data = remainingTicks;
            
            // Make sure all datasets are visible and correctly configured
            totalLiquidityChartInstance.data.datasets.forEach((dataset, index) => {
              dataset.hidden = false;
              console.log(`Dataset ${index} visibility:`, !dataset.hidden);
              
              // Ensure proper bar thickness
              if (!dataset.barThickness || dataset.barThickness < 2) {
                dataset.barThickness = 2;
              }
              
              // Ensure proper stacking
              dataset.stack = "liquidity";
            });
            
            // Always ensure mark price annotation exists
            if (totalLiquidityChartInstance.options && 
                totalLiquidityChartInstance.options.plugins && 
                totalLiquidityChartInstance.options.plugins.annotation) {
              
              if (!totalLiquidityChartInstance.options.plugins.annotation.annotations) {
                totalLiquidityChartInstance.options.plugins.annotation.annotations = {};
              }
              
              // Create or update the mark price line
              totalLiquidityChartInstance.options.plugins.annotation.annotations.markPriceLine = {
                type: "line",
                mode: "vertical",
                scaleID: "x",
                value: spotPriceGlobal,
                borderColor: "#85C1E9",
                borderWidth: 2,
                label: { enabled: true, content: "Mark Price", color: "#fff" }
              };
            }
            
            // Use immediate update with minimal animation
          totalLiquidityChartInstance.update("none");
            console.log("Chart colors updated successfully");
            
            // Verify datasets after update
            setTimeout(() => {
              if (totalLiquidityChartInstance && totalLiquidityChartInstance.data) {
                console.log("After update - Dataset 0 length:", 
                          totalLiquidityChartInstance.data.datasets[0].data.length,
                          "Dataset 1 length:", 
                          totalLiquidityChartInstance.data.datasets[1].data.length);
              }
            }, 100);
          } else {
            console.error("Chart doesn't have the expected datasets");
          }
        } else {
          console.error("Chart not available or no data to display");
        }
      }
      
      /******************************************************
       * ENSURE MARK PRICE LINE IS VISIBLE
       ******************************************************/
      
        if (totalLiquidityChartInstance && 
            totalLiquidityChartInstance.options && 
            totalLiquidityChartInstance.options.plugins && 
            totalLiquidityChartInstance.options.plugins.annotation) {
          
          if (!totalLiquidityChartInstance.options.plugins.annotation.annotations) {
            totalLiquidityChartInstance.options.plugins.annotation.annotations = {};
          }
          
          totalLiquidityChartInstance.options.plugins.annotation.annotations.markPriceLine = {
            type: "line",
            mode: "vertical",
            scaleID: "x",
            value: spotPriceGlobal,
            borderColor: "#85C1E9", 
            borderWidth: 2,
            label: { enabled: true, content: "Mark Price", color: "#fff" }
          };
          
          totalLiquidityChartInstance.update('none');
        }
      
      
      /******************************************************
       * RENDER LIQUIDITY CHART (Options)
       ******************************************************/
      async function renderLiquidityChart() {
        console.log("Rendering liquidity chart");
        const market = document.getElementById("marketSelect").value;
        let ticks = await fetchLiquidityData(market);
        const optionType = document.getElementById("optionType").value;
        
        console.log("Fetch complete, processing data");
        console.log("Ticks length:", ticks.length);
        
        let processed = ticks.map(t => {
          let avail = t.availableLiquidity;
          let tot = t.totalLiquidity;
          const symbol = t.tokenSymbol ? t.tokenSymbol.toLowerCase() : "";
          if (symbol.includes("ws") || symbol.includes("weth")) {
            avail *= spotPriceGlobal;
            tot *= spotPriceGlobal;
          }
          return { strike: t.strike, avail, locked: tot - avail };
        });
        
        window.processedLiquidityData = processed;
        console.log("Processed data length:", processed.length);
        
        const strikes = processed.map(p => p.strike);
        const dataMin = Math.min(...strikes);
        const dataMax = Math.max(...strikes);
        let xMin = zoomPreset ? zoomPreset.min : dataMin;
        let xMax = zoomPreset ? zoomPreset.max : dataMax;
        
        console.log("Data range:", dataMin, "to", dataMax);
        console.log("Display range:", xMin, "to", xMax);
        
        const lockedData = processed.map(p => ({ x: p.strike, y: p.locked }));
        const initialUtilized = processed.map(p => ({ x: p.strike, y: 0 }));
        const initialRemaining = processed.map(p => ({ x: p.strike, y: p.avail }));
        
        const container = document.getElementById("topChartContainer");
        container.innerHTML = `<canvas id="liquidityChart" width="600" height="250"></canvas>`;
        const ctx = document.getElementById("liquidityChart").getContext("2d");
        
        // Make sure to destroy any existing chart
        destroyTotalLiquidityChart();
        
        // Define mark price line annotation
        const annotationConfig = {
          markPriceLine: {
            type: "line",
            mode: "vertical",
            scaleID: "x",
            value: spotPriceGlobal,
            borderColor: "#85C1E9",
            borderWidth: 2,
            label: { enabled: true, content: "Mark Price", color: "#fff" }
          }
        };
        
        console.log("Creating new chart instance");
        // Create new chart with carefully defined datasets
        totalLiquidityChartInstance = new Chart(ctx, {
          type: "bar",
          data: {
            datasets: [
              {
                label: "Selected Liquidity (USD)",
                data: initialUtilized,
                backgroundColor: "#60a5fa",
                stack: "liquidity",
                barThickness: 2,
                hidden: false
              },
              {
                label: "Remaining Liquidity (USD)",
                data: initialRemaining,
                backgroundColor: "rgba(15,255,149,0.8)",
                stack: "liquidity",
                barThickness: 2,
                hidden: false
              },
              {
                label: "Locked Liquidity (USD)",
                data: lockedData,
                backgroundColor: "rgba(255,99,132,0.8)",
                stack: "liquidity",
                barThickness: 2,
                hidden: false
              }
            ]
          },
          options: {
            responsive: true,
            parsing: false,
            plugins: {
              tooltip: {
                callbacks: { label: ctx => ctx.dataset.label + ": " + formatNumber(ctx.parsed.y) }
              },
              legend: { labels: { color: "#fff" } },
              annotation: { annotations: annotationConfig }
            },
            scales: {
              x: {
                type: "linear",
                position: "bottom",
                min: xMin,
                max: xMax,
                ticks: { color: "#fff", callback: val => parseFloat(val).toFixed(2) },
                grid: { color: "rgba(255,255,255,0.1)" }
              },
              y: {
                type: useLogScale ? "logarithmic" : "linear",
                min: useLogScale ? 1 : 0,
                stacked: true,
                ticks: { color: "#fff" },
                grid: { color: "rgba(255,255,255,0.1)" }
              }
            }
          },
          plugins: [draggableRangePlugin]
        });
        
        console.log("Chart instance created");
        console.log("Datasets loaded:", 
                    totalLiquidityChartInstance.data.datasets.length,
                    "Dataset 0 points:", 
                    totalLiquidityChartInstance.data.datasets[0].data.length);
        
        // Update the chart colors based on current slider values
        updateChartColors();
        console.log("Chart rendering complete");
      }
      
      /******************************************************
       * RENDER PnL CHART (Options â€“ Modal)
       ******************************************************/
      function renderPnLChart() {
        const container = document.getElementById("modalPnL");
        container.innerHTML = `<canvas id="modalPnLChart" width="600" height="250"></canvas>`;
        const ctx = document.getElementById("modalPnLChart").getContext("2d");
        destroyPnLChart();
        let annotations = {
          markPriceLine: {
            type: "line",
            mode: "vertical",
            scaleID: "x",
            value: spotPriceGlobal,
            borderColor: "#85C1E9",
            borderWidth: 2,
            label: { enabled: true, content: "Mark Price", color: "#fff" }
          },
          premiumLine: {
            type: "line",
            mode: "horizontal",
            scaleID: "y",
            value: tradeData.totalPremium || 0,
            borderColor: "green",
            borderWidth: 2,
            label: { enabled: true, content: "Total Premium", color: "#fff" }
          }
        };
        if (tradeData.optionType === "strangle") {
          if (tradeData.callExposureStrike != null) {
            annotations.callExposureLine = {
              type: "line",
              mode: "vertical",
              scaleID: "x",
              value: tradeData.callExposureStrike,
              borderColor: "orange",
              borderWidth: 2,
              label: { enabled: true, content: "Call Exposure Filled", color: "#fff" }
            };
          }
          if (tradeData.putExposureStrike != null) {
            annotations.putExposureLine = {
              type: "line",
              mode: "vertical",
              scaleID: "x",
              value: tradeData.putExposureStrike,
              borderColor: "purple",
              borderWidth: 2,
              label: { enabled: true, content: "Put Exposure Filled", color: "#fff" }
            };
          }
        } else {
          annotations.exposureLine = {
            type: "line",
            mode: "vertical",
            scaleID: "x",
            value: tradeData.exposureStrike,
            borderColor: "orange",
            borderWidth: 2,
            label: { enabled: true, content: "Exposure Filled", color: "#fff" }
          };
        }
        pnlChartInstance = new Chart(ctx, {
          type: "line",
          data: {
            labels: tradeData.underlyingPrices || [],
            datasets: [{
              label: "Cumulative Payoff",
              data: tradeData.payoffCurve || [],
              borderColor: "#ffcc00",
              fill: false,
              tension: 0.2
            }]
          },
          options: {
            responsive: true,
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ": " + context.parsed.y.toFixed(4);
                  }
                }
              },
              legend: { labels: { color: "#fff" } },
              annotation: { annotations: annotations }
            },
            scales: {
              x: {
                type: "linear",
                position: "bottom",
                title: { display: true, text: "Price", color: "#ffcc00" },
                min: tradeData.underlyingPrices ? tradeData.underlyingPrices[0] : 0,
                max: tradeData.underlyingPrices ? tradeData.underlyingPrices[tradeData.underlyingPrices.length - 1] : 1,
                ticks: { color: "#fff", callback: value => parseFloat(value).toFixed(2) },
                grid: { color: "rgba(255,255,255,0.2)" }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: "Cumulative Payoff", color: "#ffcc00" },
                ticks: { color: "#fff" },
                grid: { color: "rgba(255,255,255,0.2)" }
              }
            }
          }
        });
      }
      
      /******************************************************
       * RENDER MODAL TABLE (Options â€“ Modal)
       ******************************************************/
      function renderModalTable() {
        let html = "";
        if (tradeData.optionType === "strangle") {
          html += `<h3 class="text-white">Call Purchases</h3>
            <table id="liquidityTable" class="min-w-full divide-y divide-gray-400 dark:divide-gray-700 text-sm">
              <thead class="table-3d">
                <tr>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Range</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Amount</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Premium</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Token</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Breakdown</th>
                </tr>
              </thead>
              <tbody class="divide-y divide-gray-300 dark:divide-gray-700">`;
          if (tradeData.chosenTicksCalls && tradeData.chosenTicksCalls.length > 0) {
            const firstStrike = tradeData.chosenTicksCalls[0].strike;
            const lastStrike = tradeData.chosenTicksCalls[tradeData.chosenTicksCalls.length - 1].strike;
            const totalUsed = tradeData.chosenTicksCalls.reduce((sum, t) => sum + t.usedLiquidity, 0);
            html += `<tr class="hover:bg-gray-100 dark:hover:bg-gray-800">
              <td class="px-4 py-2">${firstStrike.toFixed(4)} - ${lastStrike.toFixed(4)}</td>
              <td class="px-4 py-2">${totalUsed}</td>
              <td class="px-4 py-2">${tradeData.totalPremium ? tradeData.totalPremium.toFixed(4) : 0}</td>
              <td class="px-4 py-2">${tradeData.chosenTicksCalls[0].tokenSymbol}</td>
              <td class="px-4 py-2">
                <details>
                  <summary class="cursor-pointer text-neonGreen">Show Breakdown</summary>
                  <table class="min-w-full mt-2 text-xs">
                    <tr>
                      <th class="px-2 py-1">Strike</th>
                      <th class="px-2 py-1">Amount</th>
                      <th class="px-2 py-1">Premium</th>
                      <th class="px-2 py-1">Token</th>
                    </tr>`;
            tradeData.chosenTicksCalls.forEach(tick => {
              html += `<tr class="hover:bg-gray-100 dark:hover:bg-gray-800">
                <td class="px-2 py-1">${tick.strike.toFixed(4)}</td>
                <td class="px-2 py-1">${tick.usedLiquidity}</td>
                <td class="px-2 py-1">${tick.premiumCost ? tick.premiumCost.toFixed(4) : 0}</td>
                <td class="px-2 py-1">${tick.tokenSymbol}</td>
              </tr>`;
            });
            html += `</table>
                </details>
              </td>
            </tr>`;
          } else {
            html += `<tr><td colspan="5" class="px-4 py-2">No call data available.</td></tr>`;
          }
          html += `</tbody></table>`;
          
          html += `<h3 class="text-white mt-4">Put Purchases</h3>
            <table id="liquidityTable" class="min-w-full divide-y divide-gray-400 dark:divide-gray-700 text-sm">
              <thead class="table-3d">
                <tr>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Range</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Amount</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Premium</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Token</th>
                  <th class="px-4 py-3 uppercase tracking-wider text-left">Breakdown</th>
                </tr>
              </thead>
              <tbody class="divide-y divide-gray-300 dark:divide-gray-700">`;
          if (tradeData.chosenTicksPuts && tradeData.chosenTicksPuts.length > 0) {
            const firstStrike = tradeData.chosenTicksPuts[0].strike;
            const lastStrike = tradeData.chosenTicksPuts[tradeData.chosenTicksPuts.length - 1].strike;
            const totalUsed = tradeData.chosenTicksPuts.reduce((sum, t) => sum + t.usedLiquidity, 0);
            html += `<tr class="hover:bg-gray-100 dark:hover:bg-gray-800">
              <td class="px-4 py-2">${firstStrike.toFixed(4)} - ${lastStrike.toFixed(4)}</td>
              <td class="px-4 py-2">${totalUsed}</td>
              <td class="px-4 py-2">${tradeData.totalPremium ? tradeData.totalPremium.toFixed(4) : 0}</td>
              <td class="px-4 py-2">${tradeData.chosenTicksPuts[0].tokenSymbol}</td>
              <td class="px-4 py-2">
                <details>
                  <summary class="cursor-pointer text-neonGreen">Show Breakdown</summary>
                  <table class="min-w-full mt-2 text-xs">
                    <tr>
                      <th class="px-2 py-1">Strike</th>
                      <th class="px-2 py-1">Amount</th>
                      <th class="px-2 py-1">Premium</th>
                      <th class="px-2 py-1">Token</th>
                    </tr>`;
            tradeData.chosenTicksPuts.forEach(tick => {
              html += `<tr class="hover:bg-gray-100 dark:hover:bg-gray-800">
                <td class="px-2 py-1">${tick.strike.toFixed(4)}</td>
                <td class="px-2 py-1">${tick.usedLiquidity}</td>
                <td class="px-2 py-1">${tick.premiumCost ? tick.premiumCost.toFixed(4) : 0}</td>
                <td class="px-2 py-1">${tick.tokenSymbol}</td>
              </tr>`;
            });
            html += `</table>
                </details>
              </td>
            </tr>`;
          } else {
            html += `<tr><td colspan="5" class="px-4 py-2">No put data available.</td></tr>`;
          }
          html += `</tbody></table>`;
        } else {
          let htmlSingle = `<table id="liquidityTable" class="min-w-full divide-y divide-gray-400 dark:divide-gray-700 text-sm">
            <thead class="table-3d">
              <tr>
                <th class="px-4 py-3 uppercase tracking-wider text-left">Range</th>
                <th class="px-4 py-3 uppercase tracking-wider text-left">Amount</th>
                <th class="px-4 py-3 uppercase tracking-wider text-left">Premium</th>
                <th class="px-4 py-3 uppercase tracking-wider text-left">Token</th>
                <th class="px-4 py-3 uppercase tracking-wider text-left">Breakdown</th>
              </tr>
            </thead>
            <tbody class="divide-y divide-gray-300 dark:divide-gray-700">`;
          if (tradeData.chosenTicks && tradeData.chosenTicks.length > 0) {
            const firstStrike = tradeData.chosenTicks[0].strike;
            const lastStrike = tradeData.chosenTicks[tradeData.chosenTicks.length - 1].strike;
            const totalUsed = tradeData.chosenTicks.reduce((sum, t) => sum + t.usedLiquidity, 0);
            htmlSingle += `<tr class="hover:bg-gray-100 dark:hover:bg-gray-800">
              <td class="px-4 py-2">${firstStrike.toFixed(4)} - ${lastStrike.toFixed(4)}</td>
              <td class="px-4 py-2">${totalUsed}</td>
              <td class="px-4 py-2">${tradeData.totalPremium ? tradeData.totalPremium.toFixed(4) : 0}</td>
              <td class="px-4 py-2">${tradeData.chosenTicks[0].tokenSymbol}</td>
              <td class="px-4 py-2">
                <details>
                  <summary class="cursor-pointer text-neonGreen">Show Breakdown</summary>
                  <table class="min-w-full mt-2 text-xs">
                    <tr>
                      <th class="px-2 py-1">Strike</th>
                      <th class="px-2 py-1">Amount</th>
                      <th class="px-2 py-1">Premium</th>
                      <th class="px-2 py-1">Token</th>
                    </tr>`;
            tradeData.chosenTicks.forEach(tick => {
              htmlSingle += `<tr class="hover:bg-gray-100 dark:hover:bg-gray-800">
                <td class="px-2 py-1">${tick.strike.toFixed(4)}</td>
                <td class="px-2 py-1">${tick.usedLiquidity}</td>
                <td class="px-2 py-1">${tick.premiumCost ? tick.premiumCost.toFixed(4) : 0}</td>
                <td class="px-2 py-1">${tick.tokenSymbol}</td>
              </tr>`;
            });
            htmlSingle += `</table>
                </details>
              </td>
            </tr>`;
          } else {
            htmlSingle += `<tr><td colspan="5" class="px-4 py-2">No data available.</td></tr>`;
          }
          htmlSingle += `</tbody></table>`;
          html = htmlSingle;
        }
        document.getElementById("modalTable").innerHTML = html;
      }
      
      /******************************************************
       * PERP FUNCTIONS (Unchanged)
       ******************************************************/
      function renderPerpDepthChart() {
        const container = document.getElementById("topChartContainer");
        container.innerHTML = `<canvas id="perpDepthChart" width="600" height="250"></canvas>`;
        const ctx = document.getElementById("perpDepthChart").getContext("2d");
        let dataPoints = [];
        let cumulativeLiquidity = 0;
        if (tradeData.positionType === "long") {
          tradeData.chosenTicks.forEach(t => {
            cumulativeLiquidity += t.usedLiquidity;
            dataPoints.push({ x: t.strike, y: cumulativeLiquidity });
          });
        } else {
          let reversed = [...tradeData.chosenTicks].reverse();
          cumulativeLiquidity = 0;
          reversed.forEach(t => {
            cumulativeLiquidity += t.usedLiquidity;
            dataPoints.push({ x: t.strike, y: cumulativeLiquidity });
          });
        }
        new Chart(ctx, {
          type: "line",
          data: {
            datasets: [{
              label: "Cumulative Liquidity",
              data: dataPoints,
              borderColor: "#0FFF95",
              fill: false,
              tension: 0.2
            }]
          },
          options: {
            responsive: true,
            scales: {
              x: {
                type: "linear",
                position: "bottom",
                ticks: { color: "#fff", callback: val => parseFloat(val).toFixed(2) },
                grid: { color: "rgba(255,255,255,0.1)" }
              },
              y: {
                beginAtZero: true,
                ticks: { color: "#fff" },
                grid: { color: "rgba(255,255,255,0.1)" }
              }
            },
            plugins: {
              legend: { labels: { color: "#fff" } }
            }
          }
        });
      }
      
      function renderPerpTable() {
        let html = `<table id="liquidityTable" class="min-w-full divide-y divide-gray-400 dark:divide-gray-700 text-sm">
          <thead class="table-3d">
            <tr>
              <th class="px-4 py-3 uppercase tracking-wider text-left">Strike</th>
              <th class="px-4 py-3 uppercase tracking-wider text-left">Used Liquidity</th>
              <th class="px-4 py-3 uppercase tracking-wider text-left">Premium</th>
              <th class="px-4 py-3 uppercase tracking-wider text-left">Token</th>
            </tr>
          </thead>
          <tbody class="divide-y divide-gray-300 dark:divide-gray-700">`;
        if (tradeData.chosenTicks && tradeData.chosenTicks.length > 0) {
          tradeData.chosenTicks.forEach(tick => {
            html += `<tr class="hover:bg-gray-100 dark:hover:bg-gray-800">
              <td class="px-4 py-2">${tick.strike.toFixed(4)}</td>
              <td class="px-4 py-2">${tick.usedLiquidity}</td>
              <td class="px-4 py-2">${tick.premiumCost ? tick.premiumCost.toFixed(4) : 0}</td>
              <td class="px-4 py-2">${tick.tokenSymbol}</td>
            </tr>`;
          });
        } else {
          html += `<tr><td colspan="4" class="px-4 py-2">No data available.</td></tr>`;
        }
        html += `</tbody></table>`;
        document.getElementById("bottomViewContainer").innerHTML = html;
      }
      
      function renderPerpPnLChart() {
        const container = document.getElementById("topChartContainer");
        container.innerHTML = `<canvas id="perpPnLChart" width="600" height="250"></canvas>`;
        const ctx = document.getElementById("perpPnLChart").getContext("2d");
        destroyPnLChart();
        let annotations = {
          markPriceLine: {
            type: "line",
            mode: "vertical",
            scaleID: "x",
            value: spotPriceGlobal,
            borderColor: "#85C1E9",
            borderWidth: 2,
            label: { enabled: true, content: "Mark Price", color: "#fff" }
          },
          premiumLine: {
            type: "line",
            mode: "horizontal",
            scaleID: "y",
            value: tradeData.totalPremium || 0,
            borderColor: "green",
            borderWidth: 2,
            label: { enabled: true, content: "Total Premium", color: "#fff" }
          }
        };
        pnlChartInstance = new Chart(ctx, {
          type: "line",
          data: {
            labels: tradeData.underlyingPrices || [],
            datasets: [{
              label: "Cumulative Payoff",
              data: tradeData.payoffCurve || [],
              borderColor: "#ffcc00",
              fill: false,
              tension: 0.2
            }]
          },
          options: {
            responsive: true,
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    return context.dataset.label + ": " + context.parsed.y.toFixed(4);
                  }
                }
              },
              legend: { labels: { color: "#fff" } },
              annotation: { annotations: annotations }
            },
            scales: {
              x: {
                type: "linear",
                position: "bottom",
                title: { display: true, text: "Price", color: "#ffcc00" },
                min: tradeData.underlyingPrices ? tradeData.underlyingPrices[0] : 0,
                max: tradeData.underlyingPrices ? tradeData.underlyingPrices[tradeData.underlyingPrices.length - 1] : 1,
                ticks: { color: "#fff", callback: value => parseFloat(value).toFixed(2) },
                grid: { color: "rgba(255,255,255,0.2)" }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: "Cumulative Payoff", color: "#ffcc00" },
                ticks: { color: "#fff" },
                grid: { color: "rgba(255,255,255,0.2)" }
              }
            }
          }
        });
      }
      
      /******************************************************
       * MODAL FUNCTIONS
       ******************************************************/
      function openModal() {
        // Show the Table tab by default
        document.getElementById("modalTable").classList.remove("hidden");
        document.getElementById("modalPnL").classList.add("hidden");
        document.getElementById("tabTable").classList.add("active");
        document.getElementById("tabPnL").classList.remove("active");
        renderModalTable();
        document.getElementById("modalPopup").classList.add("active");
      }
      
      function closeModal() {
        document.getElementById("modalPopup").classList.remove("active");
      }
      
      document.getElementById("modalPopup").addEventListener("click", (e) => {
        if (e.target === document.getElementById("modalPopup")) {
          closeModal();
        }
      });
      document.getElementById("modalClose").addEventListener("click", closeModal);
      document.getElementById("tabTable").addEventListener("click", () => {
        document.getElementById("modalTable").classList.remove("hidden");
        document.getElementById("modalPnL").classList.add("hidden");
        document.getElementById("tabTable").classList.add("active");
        document.getElementById("tabPnL").classList.remove("active");
        renderModalTable();
      });
      document.getElementById("tabPnL").addEventListener("click", () => {
        document.getElementById("modalPnL").classList.remove("hidden");
        document.getElementById("modalTable").classList.add("hidden");
        document.getElementById("tabPnL").classList.add("active");
        document.getElementById("tabTable").classList.remove("active");
        renderPnLChart();
      });
      
      /******************************************************
       * SUBMIT BUTTONS
       ******************************************************/
      document.getElementById("submitBtn").addEventListener("click", async () => {
        if (currentProductType === "options") {
          // Do not reset inputs on submit; load trade data and open modal
          await loadTradePage(false);
          openModal();
        }
      });
      document.getElementById("submitBtnPerp").addEventListener("click", () => {
        if (currentProductType === "perp") {
          loadPerpTradePage();
        }
      });
      document.getElementById("refreshButton").addEventListener("click", () => {
        if (currentProductType === "options") {
          loadTradePage(true);
        } else if (currentProductType === "perp") {
          loadPerpTradePage();
        }
      });
      
      /******************************************************
       * PRODUCT TYPE TOGGLES
       ******************************************************/
      document.getElementById("toggleOptions").addEventListener("click", () => {
        currentProductType = "options";
        document.getElementById("toggleOptions").classList.add("active");
        document.getElementById("togglePerp").classList.remove("active");
        document.getElementById("tradeControlsOptions").style.display = "flex";
        document.getElementById("tradeControlsPerp").style.display = "none";
        document.getElementById("zoomContainer").style.display = "flex";
        updateTopPanelView();
      });
      document.getElementById("togglePerp").addEventListener("click", () => {
        currentProductType = "perp";
        document.getElementById("togglePerp").classList.add("active");
        document.getElementById("toggleOptions").classList.remove("active");
        document.getElementById("tradeControlsOptions").style.display = "none";
        document.getElementById("tradeControlsPerp").style.display = "flex";
        document.getElementById("zoomContainer").style.display = "none";
        updateTopPanelView();
      });
      document.getElementById("toggleLong").addEventListener("click", () => {
        document.getElementById("toggleLong").classList.add("active");
        document.getElementById("toggleShort").classList.remove("active");
      });
      document.getElementById("toggleShort").addEventListener("click", () => {
        document.getElementById("toggleShort").classList.add("active");
        document.getElementById("toggleLong").classList.remove("active");
      });
      
      /******************************************************
       * MARKET & OPTION TYPE CHANGES
       ******************************************************/
      document.getElementById("marketSelect").addEventListener("change", async () => {
        zoomPreset = null;
        await loadTradePage(true);
        updateTopPanelView();
        
        // Reset zoom toggle buttons to match the chart's "full" state
        document.querySelectorAll(".zoom-preset-btn").forEach(btn => btn.classList.remove("active"));
        const fullZoomBtn = document.querySelector(`.zoom-preset-btn[data-preset="full"]`);
        if (fullZoomBtn) fullZoomBtn.classList.add("active");
      });
      document.getElementById("optionType").addEventListener("change", () => {
        // Update the toggle UI to reflect the new option type
        updateOptionTypeToggle();
        
        if (spotPriceGlobal) {
          const optType = document.getElementById("optionType").value;
          document.getElementById("optionDynamicControls").style.display = "block";
          if (optType === "call") {
            document.getElementById("callMinInput").value = spotPriceGlobal.toFixed(4);
            document.getElementById("callMaxInput").value = (spotPriceGlobal * 1.05).toFixed(4);
            document.getElementById("callControls").style.display = "block";
            document.getElementById("putControls").style.display = "none";
          } else if (optType === "put") {
            document.getElementById("putMaxInput").value = spotPriceGlobal.toFixed(4);
            document.getElementById("putMinInput").value = (spotPriceGlobal * 0.95).toFixed(4);
            document.getElementById("callControls").style.display = "none";
            document.getElementById("putControls").style.display = "block";
          } else if (optType === "strangle") {
            document.getElementById("callMinInput").value = spotPriceGlobal.toFixed(4);
            document.getElementById("callMaxInput").value = (spotPriceGlobal * 1.05).toFixed(4);
            document.getElementById("putMaxInput").value = spotPriceGlobal.toFixed(4);
            document.getElementById("putMinInput").value = (spotPriceGlobal * 0.95).toFixed(4);
            document.getElementById("callControls").style.display = "block";
            document.getElementById("putControls").style.display = "block";
          }
          updateTopPanelView();
          document.getElementById("tradeAmountCall").value = 0;
          document.getElementById("callAmountInput").value = "0.00";
          document.getElementById("callAvailableLiquidity").textContent = "Available: $0";
          document.getElementById("tradeAmountPut").value = 0;
          document.getElementById("putAmountInput").value = "0.00";
          document.getElementById("putAvailableLiquidity").textContent = "Available: $0";
        }
      });
      
      document.getElementById("callMinInput").addEventListener("change", (e) => {
        let val = parseFloat(e.target.value) || 0;
        
        // Enforce constraint: call min cannot go below mark price
        val = Math.max(val, spotPriceGlobal);
        
        // Make sure callMin doesn't exceed callMax
        const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
        val = Math.min(val, callMax - 0.0001);
        
        e.target.value = val.toFixed(4);
        updateTopPanelView();
      });
      
      document.getElementById("callMaxInput").addEventListener("change", (e) => {
        let val = parseFloat(e.target.value) || 0;
        
        // Make sure callMax isn't less than callMin
        const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
        val = Math.max(val, callMin + 0.0001);
        
        e.target.value = val.toFixed(4);
        updateTopPanelView();
      });
      
      document.getElementById("putMaxInput").addEventListener("change", (e) => {
        let val = parseFloat(e.target.value) || 0;
        
        // Enforce constraint: put max cannot go above mark price
        val = Math.min(val, spotPriceGlobal);
        
        // Make sure putMax isn't less than putMin
        const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
        val = Math.max(val, putMin + 0.0001);
        
        e.target.value = val.toFixed(4);
        updateTopPanelView();
      });
      
      document.getElementById("putMinInput").addEventListener("change", (e) => {
        let val = parseFloat(e.target.value) || 0;
        
        // Make sure putMin doesn't exceed putMax
        const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
        val = Math.min(val, putMax - 0.0001);
        
        e.target.value = val.toFixed(4);
        updateTopPanelView();
      });
      
      // Find and update the slider event listeners
      document.getElementById("tradeAmountCall").addEventListener("input", (e) => {
        // We'll update display via updateChartColors for consistency
        updateChartColors();
        
        // Force chart update to ensure colors change
        if (totalLiquidityChartInstance) {
          totalLiquidityChartInstance.update();
        }
      });
      
      document.getElementById("tradeAmountPut").addEventListener("input", (e) => {
        // We'll update display via updateChartColors for consistency
        updateChartColors();
        
        // Force chart update to ensure colors change
        if (totalLiquidityChartInstance) {
          totalLiquidityChartInstance.update();
        }
      });
      
      /******************************************************
       * DARK/LIGHT MODE TOGGLE (Defensive fix)
       ******************************************************/
      
      setInterval(() => {
        const secsAgo = Math.floor((Date.now() - lastUpdateTime) / 1000);
        document.getElementById('lastUpdated').innerText = 'Last Updated: ' + secsAgo + ' secs ago';
      }, 1000);
      
      /******************************************************
       * INITIALIZATION
       ******************************************************/
      async function init() {
        document.getElementById("tradeAmountCall").value = 0;
        document.getElementById("callAmountInput").value = "0.00";
        document.getElementById("callAvailableLiquidity").textContent = "Available: $0";
        document.getElementById("tradeAmountPut").value = 0;
        document.getElementById("putAmountInput").value = "0.00";
        document.getElementById("putAvailableLiquidity").textContent = "Available: $0";
        document.getElementById("tradeAmountPerp").value = 1;
        zoomPreset = null;
        
        // Set initial active state for option type toggle
        updateOptionTypeToggle();
        
        // Add event listeners for zoom preset buttons
        document.querySelectorAll('.zoom-preset-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const preset = btn.getAttribute('data-preset');
            setZoomPreset(preset);
          });
        });
        
        // We'll let the market initialization handle loading the page
        document.getElementById("optionDynamicControls").style.display = "block";
      }

      // Call the function to fetch and add markets to the selector when the page loads
      document.addEventListener('DOMContentLoaded', async () => {
        console.log("DOM loaded, initializing markets...");
        
        // Initialize the UI
        init();
        
        // Set default option type to "call"
        document.getElementById("optionType").value = "call";
        updateOptionTypeToggle();
        
        // Fetch and add markets to selector
        await fetchAndAddMarketsToSelector();
        
        // Add event listener for market selection
        const marketSelect = document.getElementById('marketSelect');
        if (marketSelect) {
          console.log("Adding event listener to market select");
          marketSelect.addEventListener('change', (event) => {
            console.log("Market changed:", event.target.value);
            const selectedMarketAddress = event.target.value;
            fetchMarketData(selectedMarketAddress);
          });
        } else {
          console.error("Market select element not found for event listener!");
        }
      });
      
      /******************************************************
       * LOAD TRADE PAGE (Options)
       * resetSelectors: true resets defaults; false leaves inputs intact.
       ******************************************************/
      async function loadTradePage(resetSelectors = true) {
        try {
        lastUpdateTime = Date.now();
        const marketChoice = document.getElementById("marketSelect").value;
        const ttlSeconds = parseInt(document.getElementById("expirySelect").value);
        const optionType = document.getElementById("optionType").value;
        const userAddress = "0xf8859BAae87Eac4C7EE0b81499eDDD99c778FBEB";
          
          // Check if this is a new market (value is the address) or old market (value is a key in marketConfig)
          const isNewMarket = marketChoice.startsWith('0x') && marketChoice.length >= 40;
          
          let optionMarket = "";
          if (isNewMarket) {
            optionMarket = marketChoice; // For new markets, the value is already the address
            console.log("Loading new market with address:", optionMarket);
          } else {
            optionMarket = marketConfig[marketChoice] 
          ? marketConfig[marketChoice].optionMarket
          : marketConfig["S"].optionMarket;
            console.log("Loading old market with address:", optionMarket);
          }
          
          // Fetch spot price
          if (isNewMarket && marketsData) {
            const selectedMarket = marketsData.find(m => m.address === marketChoice);
            if (selectedMarket) {
              // For new markets, we need to fetch the price using the correct API
              const markPriceResponse = await fetch(`https://api.stryke.xyz/uniswap-prices/mark-price?chainId=${selectedMarket.chainId}&ticker=${selectedMarket.ticker}`);
              const markPriceData = await markPriceResponse.json();
              spotPriceGlobal = markPriceData.markPrice;
            } else {
        spotPriceGlobal = await fetchSpotPrice(marketChoice);
            }
          } else {
            spotPriceGlobal = await fetchSpotPrice(marketChoice);
          }
        
          // Update market info panel
          await updateMarketInfoPanel(marketChoice);
          
          // Reset selectors if needed
        if (resetSelectors) {
            if (optionType === "call" || optionType === "strangle") {
            document.getElementById("callMinInput").value = spotPriceGlobal.toFixed(4);
            document.getElementById("callMaxInput").value = (spotPriceGlobal * 1.05).toFixed(4);
            }
            if (optionType === "put" || optionType === "strangle") {
            document.getElementById("putMaxInput").value = spotPriceGlobal.toFixed(4);
            document.getElementById("putMinInput").value = (spotPriceGlobal * 0.95).toFixed(4);
          }
        }
          
          // Make sure we have window.liquidityLog available
          if (!window.liquidityLog || window.liquidityLog.length === 0) {
            window.liquidityLog = await fetchLiquidityData(marketChoice);
          }
          
          // Skip liquidity calculations if window.liquidityLog is undefined or empty
          if (!window.liquidityLog || window.liquidityLog.length === 0) {
            console.log("No liquidity data available, skipping liquidity calculations");
            return;
          }
        
        let availableLiquidity = 0;
        if (optionType === "call") {
          availableLiquidity = window.liquidityLog.filter(tick =>
            tick.strike >= Math.max(parseFloat(document.getElementById("callMinInput").value), spotPriceGlobal) &&
            (tick.tokenSymbol.toLowerCase().includes("ws") || tick.tokenSymbol.toLowerCase().includes("weth"))
          ).reduce((sum, tick) => sum + tick.availableLiquidity, 0);
        } else if (optionType === "put") {
          availableLiquidity = window.liquidityLog.filter(tick =>
            tick.strike <= Math.min(parseFloat(document.getElementById("putMaxInput").value), spotPriceGlobal) &&
            tick.tokenSymbol.toLowerCase().includes("usdc")
          ).reduce((sum, tick) => sum + tick.availableLiquidity, 0);
          } else if (optionType === "strangle") {
          let callLiquidity = window.liquidityLog.filter(tick =>
            tick.strike >= Math.max(parseFloat(document.getElementById("callMinInput").value), spotPriceGlobal) &&
            (tick.tokenSymbol.toLowerCase().includes("ws") || tick.tokenSymbol.toLowerCase().includes("weth"))
          ).reduce((sum, tick) => sum + tick.availableLiquidity, 0);
          let putLiquidity = window.liquidityLog.filter(tick =>
            tick.strike <= Math.min(parseFloat(document.getElementById("putMaxInput").value), spotPriceGlobal) &&
            tick.tokenSymbol.toLowerCase().includes("usdc")
          ).reduce((sum, tick) => sum + tick.availableLiquidity, 0);
          availableLiquidity = Math.min(callLiquidity, putLiquidity);
          
          // Update both the call and put available liquidity displays for strangle
          document.getElementById("callAvailableLiquidity").textContent = `Available: $${formatNumber(availableLiquidity)}`;
          document.getElementById("putAvailableLiquidity").textContent = `Available: $${formatNumber(availableLiquidity)}`;
        }
        
        let tradeAmount = 0;
        if (optionType === "call") {
          let sliderVal = parseInt(document.getElementById("tradeAmountCall").value);
          tradeAmount = availableLiquidity * (sliderVal / 100);
        } else if (optionType === "put") {
          let sliderVal = parseInt(document.getElementById("tradeAmountPut").value);
          tradeAmount = availableLiquidity * (sliderVal / 100);
          } else if (optionType === "strangle") {
          let callSliderVal = parseInt(document.getElementById("tradeAmountCall").value);
          let putSliderVal = parseInt(document.getElementById("tradeAmountPut").value);
          tradeAmount = availableLiquidity * Math.min(callSliderVal, putSliderVal) / 100;
        }
        
        const liquidityUrl = `https://api.stryke.xyz/clamm/strikes-chain?chainId=146&optionMarket=${optionMarket}&callsReach=800&putsReach=800&filterDeprecated=true`;
        try {
          const liquidityResponse = await fetch(liquidityUrl);
          const liquidityData = await liquidityResponse.json();
          let allTicks = [];
          liquidityData.forEach(item => {
            for (let key in item) {
              const data = item[key][0];
              const decimals = data.token.decimals;
              const scaledAvail = parseFloat(data.meta.availableTokenLiquidity) / Math.pow(10, decimals);
              const scaledTotal = parseFloat(data.meta.totalTokenLiquidity) / Math.pow(10, decimals);
              allTicks.push({
                strike: parseFloat(key),
                availableLiquidity: scaledAvail,
                totalLiquidity: scaledTotal,
                tokenSymbol: data.token.symbol,
                hook: data.meta.hook
              });
            }
          });
          window.liquidityLog = allTicks;
          
          let allowedHooks = ttlSeconds < 604800
            ? [intradayHook.toLowerCase(), weeklyHook.toLowerCase()]
            : [weeklyHook.toLowerCase()];
          let filteredTicksCall = [];
          let filteredTicksPut = [];
            if (optionType === "call" || optionType === "strangle") {
            filteredTicksCall = window.liquidityLog.filter(tick =>
              tick.strike >= Math.max(parseFloat(document.getElementById("callMinInput").value), spotPriceGlobal) &&
              (tick.tokenSymbol.toLowerCase().includes("ws") || tick.tokenSymbol.toLowerCase().includes("weth")) &&
              allowedHooks.includes(tick.hook.toLowerCase())
            ).sort((a, b) => a.strike - b.strike);
          }
            if (optionType === "put" || optionType === "strangle") {
            filteredTicksPut = window.liquidityLog.filter(tick =>
              tick.strike <= Math.min(parseFloat(document.getElementById("putMaxInput").value), spotPriceGlobal) &&
              tick.tokenSymbol.toLowerCase().includes("usdc") &&
              allowedHooks.includes(tick.hook.toLowerCase())
            ).sort((a, b) => b.strike - a.strike);
          }
          
          let chosenCall = [];
          let chosenPut = [];
            if (optionType === "strangle") {
            let cumulativeCall = 0;
            for (let i = 0; i < filteredTicksCall.length; i++) {
              if (cumulativeCall >= tradeAmount) break;
              let tick = { ...filteredTicksCall[i] };
              let needed = tradeAmount - cumulativeCall;
              if (tick.availableLiquidity >= needed) {
                tick.usedLiquidity = needed;
                cumulativeCall += needed;
              } else {
                tick.usedLiquidity = tick.availableLiquidity;
                cumulativeCall += tick.availableLiquidity;
              }
              chosenCall.push(tick);
            }
            let cumulativePut = 0;
            for (let i = 0; i < filteredTicksPut.length; i++) {
              if (cumulativePut >= tradeAmount) break;
              let tick = { ...filteredTicksPut[i] };
              let needed = tradeAmount - cumulativePut;
              if (tick.availableLiquidity >= needed) {
                tick.usedLiquidity = needed;
                cumulativePut += needed;
              } else {
                tick.usedLiquidity = tick.availableLiquidity;
                cumulativePut += tick.availableLiquidity;
              }
              chosenPut.push(tick);
            }
            tradeData.chosenTicksCalls = chosenCall;
            tradeData.chosenTicksPuts = chosenPut;
            tradeData.callExposureStrike = chosenCall.length > 0 ? chosenCall[chosenCall.length - 1].strike : null;
            tradeData.putExposureStrike = chosenPut.length > 0 ? chosenPut[chosenPut.length - 1].strike : null;
          } else if (optionType === "call") {
            let cumulativeCall = 0;
            for (let i = 0; i < filteredTicksCall.length; i++) {
              if (cumulativeCall >= tradeAmount) break;
              let tick = { ...filteredTicksCall[i] };
              let needed = tradeAmount - cumulativeCall;
              if (tick.availableLiquidity >= needed) {
                tick.usedLiquidity = needed;
                cumulativeCall += needed;
              } else {
                tick.usedLiquidity = tick.availableLiquidity;
                cumulativeCall += tick.availableLiquidity;
              }
              chosenCall.push(tick);
            }
            tradeData.chosenTicks = chosenCall;
            tradeData.exposureStrike = chosenCall[chosenCall.length - 1].strike;
          } else if (optionType === "put") {
            let cumulativePut = 0;
            for (let i = 0; i < filteredTicksPut.length; i++) {
              if (cumulativePut >= tradeAmount) break;
              let tick = { ...filteredTicksPut[i] };
              let needed = tradeAmount - cumulativePut;
              if (tick.availableLiquidity >= needed) {
                tick.usedLiquidity = needed;
                cumulativePut += needed;
              } else {
                tick.usedLiquidity = tick.availableLiquidity;
                cumulativePut += tick.availableLiquidity;
              }
              chosenPut.push(tick);
            }
            tradeData.chosenTicks = chosenPut;
            tradeData.exposureStrike = chosenPut[chosenPut.length - 1].strike;
          }
          
          // Fetch premiums:
          const premiumPromises = [];
            if (optionType === "strangle") {
            chosenCall.forEach(tick => {
              const tickQuoteUrl = `https://api.stryke.xyz/clamm/purchase/quote?chainId=146&optionMarket=${optionMarket}&user=${userAddress}&strike=${tick.strike}&markPrice=${spotPriceGlobal}&type=call&amount=${tick.usedLiquidity}&ttl=${ttlSeconds}`;
              premiumPromises.push(
                fetch(tickQuoteUrl)
                  .then(res => res.json())
                  .then(data => {
                    const decimals = data.token.decimals;
                    return (parseFloat(data.premium) + parseFloat(data.fees || 0)) / Math.pow(10, decimals);
                  })
                  .catch(err => {
                    console.error("Error fetching premium for tick", tick.strike, err);
                    return 0;
                  })
              );
            });
            chosenPut.forEach(tick => {
              const tickQuoteUrl = `https://api.stryke.xyz/clamm/purchase/quote?chainId=146&optionMarket=${optionMarket}&user=${userAddress}&strike=${tick.strike}&markPrice=${spotPriceGlobal}&type=put&amount=${tick.usedLiquidity}&ttl=${ttlSeconds}`;
              premiumPromises.push(
                fetch(tickQuoteUrl)
                  .then(res => res.json())
                  .then(data => {
                    const decimals = data.token.decimals;
                    return (parseFloat(data.premium) + parseFloat(data.fees || 0)) / Math.pow(10, decimals);
                  })
                  .catch(err => {
                    console.error("Error fetching premium for tick", tick.strike, err);
                    return 0;
                  })
              );
            });
          } else {
            tradeData.chosenTicks.forEach(tick => {
              const qType = optionType;
              const tickQuoteUrl = `https://api.stryke.xyz/clamm/purchase/quote?chainId=146&optionMarket=${optionMarket}&user=${userAddress}&strike=${tick.strike}&markPrice=${spotPriceGlobal}&type=${qType}&amount=${tick.usedLiquidity}&ttl=${ttlSeconds}`;
              premiumPromises.push(
                fetch(tickQuoteUrl)
                  .then(res => res.json())
                  .then(data => {
                    const decimals = data.token.decimals;
                    return (parseFloat(data.premium) + parseFloat(data.fees || 0)) / Math.pow(10, decimals);
                  })
                  .catch(err => {
                    console.error("Error fetching premium for tick", tick.strike, err);
                    return 0;
                  })
              );
            });
          }
          const chosenPremiums = await Promise.all(premiumPromises);
            if (optionType === "strangle") {
            let idx = 0;
            chosenCall.forEach(tick => {
              tick.premiumCost = chosenPremiums[idx++];
            });
            chosenPut.forEach(tick => {
              tick.premiumCost = chosenPremiums[idx++];
            });
          } else {
            tradeData.chosenTicks.forEach((tick, idx) => {
              tick.premiumCost = chosenPremiums[idx];
            });
          }
          
          // Compute cumulative payoff curve:
          let prices = [];
          let payoffCurve = [];
            if (optionType === "strangle") {
            let callStrikes = chosenCall.length > 0 ? chosenCall.map(t => t.strike) : [spotPriceGlobal];
            let putStrikes = chosenPut.length > 0 ? chosenPut.map(t => t.strike) : [spotPriceGlobal];
            let lowTick = Math.min(...callStrikes, ...putStrikes);
            let highTick = Math.max(...callStrikes, ...putStrikes);
            const steps = 50;
            const stepSize = (highTick * 1.05 - lowTick * 0.95) / steps;
            for (let p = lowTick * 0.95; p <= highTick * 1.05; p += stepSize) {
              prices.push(p);
              let callPayoff = 0;
              let putPayoff = 0;
              chosenCall.forEach(t => {
                callPayoff += Math.max(p - t.strike, 0) * t.usedLiquidity;
              });
              chosenPut.forEach(t => {
                putPayoff += Math.max(t.strike - p, 0) * t.usedLiquidity;
              });
              payoffCurve.push(callPayoff + putPayoff);
            }
          } else if (optionType === "call") {
            let lowTick = Math.min(...chosenCall.map(t => t.strike));
            let highTick = Math.max(...chosenCall.map(t => t.strike));
            const steps = 50;
            const stepSize = (highTick * 1.05 - lowTick * 0.95) / steps;
            for (let p = lowTick * 0.95; p <= highTick * 1.05; p += stepSize) {
              prices.push(p);
              let cumPayoff = 0;
              chosenCall.forEach(t => {
                cumPayoff += Math.max(p - t.strike, 0) * t.usedLiquidity;
              });
              payoffCurve.push(cumPayoff);
            }
          } else if (optionType === "put") {
            let lowTick = Math.min(...chosenPut.map(t => t.strike));
            let highTick = Math.max(...chosenPut.map(t => t.strike));
            const steps = 50;
            const stepSize = (highTick * 1.05 - lowTick * 0.95) / steps;
            for (let p = lowTick * 0.95; p <= highTick * 1.05; p += stepSize) {
              prices.push(p);
              let cumPayoff = 0;
              chosenPut.forEach(t => {
                cumPayoff += Math.max(t.strike - p, 0) * t.usedLiquidity;
              });
              payoffCurve.push(cumPayoff);
            }
          }
          tradeData = {
            ...tradeData,
            underlyingPrices: prices,
            payoffCurve: payoffCurve,
              totalPremium: (optionType === "strangle"
              ? chosenCall.concat(chosenPut)
              : tradeData.chosenTicks
            ).reduce((sum, tick) => sum + tick.premiumCost, 0),
            optionType: optionType
          };
          updateTopPanelView();
        } catch (error) {
          console.error("Error fetching or processing data:", error);
          }
        } catch (error) {
          console.error("Error in loadTradePage:", error);
        }
      }
      
      /******************************************************
       * LOAD PERP TRADE PAGE
       ******************************************************/
      async function loadPerpTradePage() {
        lastUpdateTime = Date.now();
        const marketChoice = document.getElementById("marketSelectPerp").value;
        const tradeAmount = parseFloat(document.getElementById("tradeAmountPerp").value);
        const positionType = document.getElementById("toggleLong").classList.contains("active") ? "long" : "short";
        const userAddress = "0xf8859BAae87Eac4C7EE0b81499eDDD99c778FBEB";
        const optionMarket = marketConfig[marketChoice]
          ? marketConfig[marketChoice].optionMarket
          : marketConfig["S"].optionMarket;
        spotPriceGlobal = await fetchSpotPrice(marketChoice);
      
        const liquidityData = await fetchLiquidityData(marketChoice);
        let filteredTicks = [];
        if (positionType === "long") {
          filteredTicks = liquidityData.filter(t => t.strike >= spotPriceGlobal);
          filteredTicks.sort((a, b) => a.strike - b.strike);
        } else {
          filteredTicks = liquidityData.filter(t => t.strike <= spotPriceGlobal);
          filteredTicks.sort((a, b) => b.strike - a.strike);
        }
      
        let cumulative = 0;
        let chosenTicks = [];
        for (let i = 0; i < filteredTicks.length && cumulative < tradeAmount; i++) {
          let tick = { ...filteredTicks[i] };
          let needed = tradeAmount - cumulative;
          if (tick.availableLiquidity >= needed) {
            tick.usedLiquidity = needed;
            cumulative += needed;
          } else {
            tick.usedLiquidity = tick.availableLiquidity;
            cumulative += tick.availableLiquidity;
          }
          chosenTicks.push(tick);
        }
      
        const ttlSeconds = 86400;
        const premiumPromises = chosenTicks.map(tick => {
          const qType = positionType === "long" ? "call" : "put";
          const tickQuoteUrl = `https://api.stryke.xyz/clamm/purchase/quote?chainId=146&optionMarket=${optionMarket}&user=${userAddress}&strike=${tick.strike}&markPrice=${spotPriceGlobal}&type=${qType}&amount=${tick.usedLiquidity}&ttl=${ttlSeconds}`;
          return fetch(tickQuoteUrl)
            .then(res => res.json())
            .then(data => {
              const decimals = data.token.decimals;
              return (parseFloat(data.premium) + parseFloat(data.fees || 0)) / Math.pow(10, decimals);
            })
            .catch(err => {
              console.error("Error fetching premium for tick", tick.strike, err);
              return 0;
            });
        });
        const chosenPremiums = await Promise.all(premiumPromises);
        chosenTicks.forEach((tick, idx) => {
          tick.premiumCost = chosenPremiums[idx];
        });
      
        let prices = [];
        let payoffCurve = [];
        let lowTick = Math.min(...chosenTicks.map(t => t.strike));
        let highTick = Math.max(...chosenTicks.map(t => t.strike));
        let chartMin, chartMax;
        if (positionType === "long") {
          chartMin = spotPriceGlobal * 0.95;
          chartMax = highTick * 1.05;
        } else {
          chartMin = lowTick * 0.95;
          chartMax = spotPriceGlobal * 1.05;
        }
        const steps = 50;
        const stepSize = (chartMax - chartMin) / steps;
        for (let p = chartMin; p <= chartMax; p += stepSize) {
          prices.push(p);
          let cumulativePayoff = 0;
          if (positionType === "long") {
            chosenTicks.forEach(t => {
              cumulativePayoff += Math.max(p - t.strike, 0) * t.usedLiquidity;
            });
          } else {
            chosenTicks.forEach(t => {
              cumulativePayoff += Math.max(t.strike - p, 0) * t.usedLiquidity;
            });
          }
          payoffCurve.push(cumulativePayoff);
        }
      
        tradeData = {
          chosenTicks: chosenTicks,
          underlyingPrices: prices,
          payoffCurve: payoffCurve,
          totalPremium: chosenTicks.reduce((sum, tick) => sum + tick.premiumCost, 0),
          positionType: positionType,
          productType: "perp"
        };
        updateTopPanelView();
      }
      
      /******************************************************
       * FETCH FUNCTIONS
       ******************************************************/
      async function fetchSpotPrice(market) {
        const config = marketConfig[market] || marketConfig["S"];
        const url = config.spotApi;
        try {
          const resp = await fetch(url);
          const data = await resp.json();
          console.log("Fetched markPrice:", data.markPrice);
          return parseFloat(data.markPrice);
        } catch (err) {
          console.error("Error fetching spot price:", err);
          return 0;
        }
      }
      
      async function fetchLiquidityData(market) {
        try {
          console.log("Fetching liquidity data for market:", market);
          
          // Find if this is one of the new markets
          if (marketsData && marketsData.length > 0) {
            const newMarket = marketsData.find(m => m.address === market);
            
            if (newMarket) {
              console.log(`Using new market API for ${newMarket.pairName}`);
              const liquidityUrl = `https://api.stryke.xyz/clamm/strikes-chain?chainId=${newMarket.chainId}&optionMarket=${newMarket.address}&callsReach=1000&putsReach=1000&filterDeprecated=true`;
              
              try {
                const resp = await fetch(liquidityUrl);
                const data = await resp.json();
                console.log("Liquidity data from API:", data);
                
                // Check if data is an array and has content
                if (!Array.isArray(data) || data.length === 0) {
                  console.warn("API returned empty or invalid data for the new market");
                  window.liquidityLog = [];
                  return [];
                }
                
                let ticks = [];
                data.forEach(item => {
                  for (let key in item) {
                    try {
                      const d = item[key][0];
                      if (!d || !d.token || !d.meta) {
                        console.warn("Invalid data entry:", item);
                        continue;
                      }
                      
                      const decimals = d.token.decimals;
                      const avail = parseFloat(d.meta.availableTokenLiquidity) / Math.pow(10, decimals);
                      const tot = parseFloat(d.meta.totalTokenLiquidity) / Math.pow(10, decimals);
                      ticks.push({ 
                        strike: parseFloat(key),
                        availableLiquidity: avail,
                        totalLiquidity: tot,
                        tokenSymbol: d.token.symbol
                      });
                    } catch (itemError) {
                      console.warn("Error processing item:", itemError);
                    }
                  }
                });
                
                ticks.sort((a, b) => a.strike - b.strike);
                if (ticks.length > 0) {
                  globalMinTick = ticks[0].strike;
                  globalMaxTick = ticks[ticks.length - 1].strike;
                } else {
                  console.warn("No ticks were processed from the API data");
                }
                
                // Store ticks for later use
                window.liquidityLog = ticks;
                
                return ticks;
              } catch (apiError) {
                console.error("Error fetching from new market API:", apiError);
                window.liquidityLog = [];
                return [];
              }
            }
          }
          
          // If it's not a new market or failed to fetch, use the existing configuration
          try {
        const config = marketConfig[market] || marketConfig["S"];
        const liquidityUrl = `https://api.stryke.xyz/clamm/strikes-chain?chainId=146&optionMarket=${config.optionMarket}&callsReach=800&putsReach=800&filterDeprecated=true`;
        const resp = await fetch(liquidityUrl);
        const data = await resp.json();
            
            if (!Array.isArray(data) || data.length === 0) {
              console.warn("API returned empty or invalid data for the old market");
              window.liquidityLog = [];
              return [];
            }
            
        let ticks = [];
        data.forEach(item => {
          for (let key in item) {
                try {
            const d = item[key][0];
                  if (!d || !d.token || !d.meta) {
                    console.warn("Invalid data entry in old API:", item);
                    continue;
                  }
                  
            const decimals = d.token.decimals;
            const avail = parseFloat(d.meta.availableTokenLiquidity) / Math.pow(10, decimals);
            const tot = parseFloat(d.meta.totalTokenLiquidity) / Math.pow(10, decimals);
            ticks.push({ 
              strike: parseFloat(key),
              availableLiquidity: avail,
              totalLiquidity: tot,
              tokenSymbol: d.token.symbol
            });
                } catch (itemError) {
                  console.warn("Error processing old API item:", itemError);
                }
          }
        });
            
        ticks.sort((a, b) => a.strike - b.strike);
        if (ticks.length > 0) {
          globalMinTick = ticks[0].strike;
          globalMaxTick = ticks[ticks.length - 1].strike;
        }
            
            // Store ticks for later use
            window.liquidityLog = ticks;
            
        return ticks;
          } catch (oldApiError) {
            console.error("Error fetching from old market API:", oldApiError);
            window.liquidityLog = [];
            return [];
          }
        } catch (error) {
          console.error("Error in fetchLiquidityData:", error);
          window.liquidityLog = [];
          return [];
        }
      }
      
      /******************************************************
       * UPDATE TOP PANEL VIEW
       * (For Options, the main view always shows the liquidity chart)
       ******************************************************/
      function updateTopPanelView() {
        const container = document.getElementById("topChartContainer");
        container.innerHTML = "";
        if (currentProductType === "options") {
          renderLiquidityChart();
        } else if (currentProductType === "perp") {
          renderPerpDepthChart();
        }
      }
      
      /******************************************************
       * DARK/LIGHT MODE TOGGLE
       ******************************************************/
      const modeToggle = document.getElementById('modeToggle');
      if (modeToggle) {
        modeToggle.addEventListener('click', () => {
          document.documentElement.classList.toggle('dark');
          modeToggle.classList.toggle('rotate-180');
        });
      }
      
      setInterval(() => {
        const secsAgo = Math.floor((Date.now() - lastUpdateTime) / 1000);
        document.getElementById("lastUpdated").innerText = "Last Updated: " + secsAgo + " secs ago";
      }, 1000);
      
      // Add event listeners for manual input changes to the selector values
      document.getElementById("callMinInput").addEventListener("change", () => {
        updateChartColors();
        if (totalLiquidityChartInstance) {
          totalLiquidityChartInstance.update();
        }
      });
      
      document.getElementById("callMaxInput").addEventListener("change", () => {
        updateChartColors();
        if (totalLiquidityChartInstance) {
          totalLiquidityChartInstance.update();
        }
      });
      
      document.getElementById("putMinInput").addEventListener("change", () => {
        updateChartColors();
        if (totalLiquidityChartInstance) {
          totalLiquidityChartInstance.update();
        }
      });
      
      document.getElementById("putMaxInput").addEventListener("change", () => {
        updateChartColors();
        if (totalLiquidityChartInstance) {
          totalLiquidityChartInstance.update();
        }
      });
      
      // Option type toggle event handlers
      document.querySelectorAll("[id^='optionType']").forEach(button => {
        button.addEventListener("click", function() {
          // Remove active class from all buttons
          document.querySelectorAll("[id^='optionType']").forEach(btn => {
            btn.classList.remove("active", "bg-[#0FFF95]", "text-black");
            btn.classList.add("bg-[#2A2A2A]", "text-white");
          });
          
          // Add active class to clicked button
          this.classList.add("active", "bg-[#0FFF95]", "text-black");
          this.classList.remove("bg-[#2A2A2A]", "text-white");
          
          // Set the hidden select value
          const optionType = this.getAttribute("data-option-type");
          document.getElementById("optionType").value = optionType;
          
          // Trigger the change event on the select
          const event = new Event("change");
          document.getElementById("optionType").dispatchEvent(event);
        });
      });
      
      // Set initial active state for the option type toggle based on select value
      function updateOptionTypeToggle() {
        const selectedValue = document.getElementById("optionType").value;
        
        // Store original colors when page first loads (only once)
        if (!window.originalSvgColors) {
          window.originalSvgColors = {};
          document.querySelectorAll("[id^='optionType']").forEach(button => {
            const buttonId = button.id;
            window.originalSvgColors[buttonId] = [];
            button.querySelectorAll('svg path').forEach((path, index) => {
              window.originalSvgColors[buttonId][index] = path.getAttribute('stroke');
            });
          });
        }
        
        document.querySelectorAll("[id^='optionType']").forEach(button => {
          if (button.getAttribute("data-option-type") === selectedValue) {
            // Add active classes
            button.classList.add("active", "bg-[#0FFF95]", "text-black");
            button.classList.remove("bg-[#2A2A2A]", "text-white");
            
            // Change all SVG paths to black when active
            button.querySelectorAll('svg path').forEach(path => {
              path.setAttribute('stroke', '#000000');
            });
          } else {
            // Remove active classes
            button.classList.remove("active", "bg-[#0FFF95]", "text-black");
            button.classList.add("bg-[#2A2A2A]", "text-white");
            
            // Restore original SVG path colors for this button
            const buttonId = button.id;
            button.querySelectorAll('svg path').forEach((path, index) => {
              if (window.originalSvgColors && window.originalSvgColors[buttonId]) {
                path.setAttribute('stroke', window.originalSvgColors[buttonId][index]);
              }
            });
          }
        });
      }
      
      // Call on page load
      updateOptionTypeToggle();
      
      // Add event listeners for option type toggle buttons
      document.querySelectorAll('[data-option-type]').forEach(button => {
        button.addEventListener('click', function() {
          const optionType = this.getAttribute('data-option-type');
          document.getElementById("optionType").value = optionType;
          
          // Trigger the change event on the select to update the UI
          const event = new Event('change');
          document.getElementById("optionType").dispatchEvent(event);
        });
      });
      
      // Function to update market info panel
      async function updateMarketInfoPanel(market) {
        try {
          // Check if this is a new market (an address) or old market (a key in marketConfig)
          const isNewMarket = market.startsWith('0x') && market.length >= 40;
          
          // Get references to the correct DOM elements
          const marketInfoPrice = document.getElementById('marketInfoPrice');
          const marketInfoLiquidity = document.getElementById('marketInfoLiquidity');
          const marketInfoOpenInterest = document.getElementById('marketInfoOpenInterest');
          const marketInfoVolume = document.getElementById('marketInfoVolume');
          
          // Check if elements exist
          if (!marketInfoLiquidity || !marketInfoOpenInterest || !marketInfoVolume) {
            console.warn("Some market info elements not found:", {
              marketInfoLiquidity: !!marketInfoLiquidity,
              marketInfoOpenInterest: !!marketInfoOpenInterest,
              marketInfoVolume: !!marketInfoVolume
            });
          }
          
          if (isNewMarket && marketsData) {
            const selectedMarket = marketsData.find(m => m.address === market);
            if (selectedMarket) {
              console.log("Updating market info panel for new market:", selectedMarket.pairName);
              
              // Get the market data directly from the stored data
              const totalLiquidity = selectedMarket.totalLiquidity || 0;
              const openInterest = selectedMarket.openInterest || 0;
              const volume24h = selectedMarket.volume24h || 0;
              
              // Update UI elements safely
              if (marketInfoLiquidity) marketInfoLiquidity.textContent = `$${formatNumber(totalLiquidity)}`;
              if (marketInfoOpenInterest) marketInfoOpenInterest.textContent = `$${formatNumber(openInterest)}`;
              if (marketInfoVolume) marketInfoVolume.textContent = `$${formatNumber(volume24h)}`;
              if (marketInfoPrice) marketInfoPrice.textContent = spotPriceGlobal ? `$${spotPriceGlobal.toFixed(4)}` : '--';
              
              return;
            }
          }
          
          // For old markets, use the existing approach
          try {
            // Fetch market data from the comprehensive API
            const marketDataUrl = `https://api.stryke.xyz/v1.1/clamm/option-markets?chains=42161%2C146%2C8453%2C81457%2C5000%2C80094`;
            const response = await fetch(marketDataUrl);
            const data = await response.json();
            
            // Get the config for the current market if it's an old market
            const config = marketConfig[market] || marketConfig["S"];
            
            // Find the current market in the API response
            const marketData = data.find(m => {
              if (isNewMarket) {
                return m.address && m.address.toLowerCase() === market.toLowerCase();
              } else {
                return (m.address && config && m.address.toLowerCase() === config.optionMarket.toLowerCase()) || 
                       (m.ticker && config && config.ticker && m.ticker === config.ticker);
              }
            });
            
            if (marketData) {
              // Use the API values directly for more accuracy
              const totalLiquidity = marketData.totalLiquidity || 0;
              const openInterest = marketData.openInterest || 0;
              const volume24h = marketData.volume24h || 0;
              
              // Update UI elements safely
              if (marketInfoLiquidity) marketInfoLiquidity.textContent = `$${formatNumber(totalLiquidity)}`;
              if (marketInfoOpenInterest) marketInfoOpenInterest.textContent = `$${formatNumber(openInterest)}`;
              if (marketInfoVolume) marketInfoVolume.textContent = `$${formatNumber(volume24h)}`;
              if (marketInfoPrice) marketInfoPrice.textContent = spotPriceGlobal ? `$${spotPriceGlobal.toFixed(4)}` : '--';
              
              console.log("Market data from API:", {
                totalLiquidity, openInterest, volume24h,
                market: marketData.pairName || marketData.ticker
              });
            } else {
              console.warn("Market not found in API response for:", market);
              
              // Fallback to local calculated values if API doesn't return the market data
              let totalLiquidity = 0;
              let openInterest = 0;
              
              if (window.processedLiquidityData && window.processedLiquidityData.length > 0) {
                totalLiquidity = window.processedLiquidityData.reduce((sum, p) => sum + p.avail + p.locked, 0);
                openInterest = window.processedLiquidityData.reduce((sum, p) => sum + p.locked, 0);
              }
              
              // Update UI elements safely
              if (marketInfoLiquidity) marketInfoLiquidity.textContent = `$${formatNumber(totalLiquidity)}`;
              if (marketInfoOpenInterest) marketInfoOpenInterest.textContent = `$${formatNumber(openInterest)}`;
              if (marketInfoVolume) marketInfoVolume.textContent = `--`;
            }
          } catch (error) {
            console.error("Error fetching market data:", error);
            
            // Set fallback values
            if (marketInfoLiquidity) marketInfoLiquidity.textContent = '--';
            if (marketInfoOpenInterest) marketInfoOpenInterest.textContent = '--';
            if (marketInfoVolume) marketInfoVolume.textContent = '--';
          }
        } catch (error) {
          console.error("Error in updateMarketInfoPanel:", error);
        }
      }
      
      document.getElementById("callMinInput").addEventListener("change", (e) => {
        let val = parseFloat(e.target.value) || 0;
        e.target.value = val.toFixed(4);
        updateTopPanelView();
      });
      
      function getPremium() {
        const tradeData = getTradeData();

        // Return 0 if any required values are missing
        if (!tradeData.callMin && !tradeData.putMax || !tradeData.amount) {
          return 0;
        }

        let callPremium = 0;
        let putPremium = 0;

        if (tradeData.optionType === "strangle") {
          // Calculate both call and put premiums
          if (tradeData.callMin && tradeData.callMax && parseFloat(tradeData.callAmount) > 0) {
            callPremium = calculatePremium(
              "call",
              parseFloat(tradeData.callMin),
              parseFloat(tradeData.callMax),
              parseFloat(tradeData.callAmount) / 100,
              false
            );
          }

          if (tradeData.putMin && tradeData.putMax && parseFloat(tradeData.putAmount) > 0) {
            putPremium = calculatePremium(
              "put",
              parseFloat(tradeData.putMin),
              parseFloat(tradeData.putMax),
              parseFloat(tradeData.putAmount) / 100,
              false
            );
          }

          return callPremium + putPremium;
        }
      }
      
      async function fetchAndProcessAllMarkets() {
        try {
          // Fetch all markets
          const response = await fetch('https://api.stryke.xyz/v1.1/clamm/option-markets?chains=42161%2C146%2C8453%2C81457%2C5000%2C80094');
          const markets = await response.json();

          for (const market of markets) {
            if (!market.deprecated) {
              // Fetch strikes data for each market
              const strikesResponse = await fetch(`https://api.stryke.xyz/clamm/strikes-chain?chainId=${market.chainId}&optionMarket=${market.address}&callsReach=1000&putsReach=1000&filterDeprecated=true`);
              const strikesData = await strikesResponse.json();

              // Fetch mark price for each market
              const markPriceResponse = await fetch(`https://api.stryke.xyz/uniswap-prices/mark-price?chainId=${market.chainId}&ticker=${market.ticker}`);
              const markPriceData = await markPriceResponse.json();

              // Process each strike
              for (const strike of strikesData) {
                const strikePrice = Object.keys(strike)[0];

                // Fetch option quotes for each strike
                const quoteResponse = await fetch(`https://api.stryke.xyz/clamm/purchase/quote?chainId=${market.chainId}&optionMarket=${market.address}&user=0x012afd4FE6EF8BF24858E2B7Bd309cC9e167ADe9&strike=${strikePrice}&markPrice=${markPriceData.markPrice}&type=call&amount=1&ttl=86400`);
                const quoteData = await quoteResponse.json();

                // Update UI with the fetched data
                updateMarketInfo({
                  liquidity: strike[strikePrice][0].totalLiquidity,
                  markPrice: markPriceData.markPrice,
                  quote: quoteData.quote
                });
                updateCharts({
                  liquidityData: strike[strikePrice][0].totalLiquidity
                });
              }
            }
          }
        } catch (error) {
          console.error('Error fetching and processing market data:', error);
        }
      }

      // Global variables to store market data
      let marketsData = [];
      let selectedMarketData = null;

      async function fetchAndAddMarketsToSelector() {
        try {
          console.log("Fetching markets from API...");
          
          // Fetch all markets
          const response = await fetch('https://api.stryke.xyz/v1.1/clamm/option-markets?chains=42161%2C146%2C8453%2C81457%2C5000%2C80094');
          const markets = await response.json();
          
          console.log("Markets fetched:", markets.length);
          marketsData = markets; // Store markets data globally
          
          // Define chain information
          const CHAIN_DATA = {
            42161: { 
              name: "Arbitrum", 
              color: "#2D374B", 
              logo: "https://www.stryke.xyz/images/tokens/arb.svg"
            },
            146: { 
              name: "Sonic", 
              color: "#FF0420", 
              logo: "https://www.stryke.xyz/images/tokens/ws.svg"
            },
            80094: { 
              name: "Berachain", 
              color: "#FAC807", 
              logo: "https://www.stryke.xyz/_next/image?url=%2Fimages%2Ftokens%2Fbera.png&w=48&q=75"
            },
            5000: { 
              name: "Mantle", 
              color: "#0B1811", 
              logo: "https://www.stryke.xyz/images/tokens/wmnt.svg"
            },
            81457: { 
              name: "Blast", 
              color: "#FF4500", 
              logo: "https://www.stryke.xyz/_next/image?url=%2Fimages%2Ftokens%2Fblast.png&w=48&q=75"
            },
            8453: { 
              name: "Base", 
              color: "#0052FF", 
              logo: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='28'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cpath fill='%230052FF' fill-rule='nonzero' d='M14 28a14 14 0 1 0 0-28 14 14 0 0 0 0 28Z'/%3E%3Cpath fill='%23FFF' d='M13.967 23.86c5.445 0 9.86-4.415 9.86-9.86 0-5.445-4.415-9.86-9.86-9.86-5.166 0-9.403 3.974-9.825 9.03h14.63v1.642H4.142c.413 5.065 4.654 9.047 9.826 9.047Z'/%3E%3C/g%3E%3C/svg%3E"
            }
          };
          
          // Group markets by chain
          const marketsByChain = {};
          markets.forEach(market => {
            if (!market.deprecated) {
              const chainId = market.chainId.toString();
              if (!marketsByChain[chainId]) {
                marketsByChain[chainId] = [];
              }
              marketsByChain[chainId].push(market);
            }
          });
          
          // Sort chains by name
          const sortedChainIds = Object.keys(marketsByChain).sort((a, b) => {
            const chainA = CHAIN_DATA[a] || { name: "Unknown" };
            const chainB = CHAIN_DATA[b] || { name: "Unknown" };
            return chainA.name.localeCompare(chainB.name);
          });
          
          // Find both standard select and our custom dropdown elements
          const marketSelect = document.getElementById('marketSelect');
          const marketDropdownList = document.getElementById('marketDropdownList');
          const marketDropdownButton = document.getElementById('marketDropdownButton');
          const selectedMarketText = document.getElementById('selectedMarketText');
          
          console.log("Market select elements found:", !!marketSelect, !!marketDropdownList);
          
          if (!marketSelect || !marketDropdownList) {
            console.error("Market select elements not found!");
            return;
          }
          
          // Clear existing options
          marketSelect.innerHTML = '';
          
          // Get the search box container (we keep it)
          const searchBoxContainer = marketDropdownList.querySelector('.sticky');
          
          // Clear dropdown items but keep the search box
          marketDropdownList.innerHTML = '';
          
          // Re-add the search box container if it existed
          if (searchBoxContainer) {
            marketDropdownList.appendChild(searchBoxContainer);
          }
          
          // Format a currency value with appropriate abbreviation
          const formatCurrency = (value) => {
            if (value >= 1000000) {
              return '$' + (value / 1000000).toFixed(2) + 'M';
            } else if (value >= 1000) {
              return '$' + (value / 1000).toFixed(2) + 'K';
            } else {
              return '$' + value.toFixed(2);
            }
          };
          
          let firstMarketAddress = null;
          
          // Find WETH-USDC on Arbitrum
          const wethUsdcArbitrum = markets.find(m => 
            m.chainId === 42161 && 
            m.pairName && 
            m.pairName.toLowerCase().includes('weth-usdc')
          );
          
          if (wethUsdcArbitrum) {
            firstMarketAddress = wethUsdcArbitrum.address;
            console.log("Found WETH-USDC on Arbitrum:", firstMarketAddress);
          }
          
          // Add markets to both the hidden select and the visible dropdown, grouped by chain
          sortedChainIds.forEach(chainId => {
            const chain = CHAIN_DATA[chainId] || { name: `Chain ${chainId}`, color: "#999" };
            
            // Add chain header to the dropdown
            const chainHeader = document.createElement('div');
            chainHeader.className = 'chain-header p-2 font-bold text-white flex items-center';
            chainHeader.style.backgroundColor = chain.color;
            chainHeader.innerHTML = `
              <img src="${chain.logo}" alt="${chain.name}" class="w-5 h-5 mr-2" />
              <span>${chain.name}</span>
            `;
            marketDropdownList.appendChild(chainHeader);
            
            // Sort markets by liquidity within this chain
            const chainMarkets = marketsByChain[chainId].sort((a, b) => 
              (b.totalLiquidity || 0) - (a.totalLiquidity || 0)
            );
            
            // Add markets for this chain
            chainMarkets.forEach(market => {
              console.log("Adding market to selector:", market.pairName, market.address);
              
              // Add to hidden select (for compatibility)
              const option = document.createElement('option');
              option.value = market.address; // Use market address as the value
              option.textContent = market.pairName;
              option.setAttribute('data-chain-id', chainId);
              marketSelect.appendChild(option);
              
              // Store first market address if not already set
              if (!firstMarketAddress) {
                firstMarketAddress = market.address;
              }
              
              // Add to visible dropdown with enhanced data
              const dropdownItem = document.createElement('div');
              dropdownItem.className = 'p-3 hover:bg-[#3A3A3A] cursor-pointer flex flex-col';
              dropdownItem.dataset.value = market.address;
              dropdownItem.dataset.chainId = chainId;
              
              // Format the market data
              const liquidity = formatCurrency(market.totalLiquidity || 0);
              const openInterest = formatCurrency(market.openInterest || 0);
              const volume = formatCurrency(market.volume24h || 0);
              
              // Populate the dropdown item with market data
              dropdownItem.innerHTML = `
                <div class="flex items-center justify-between">
                  <span class="font-semibold text-white">${market.pairName}</span>
                </div>
                <div class="grid grid-cols-3 gap-2 mt-1">
                  <div class="flex flex-col">
                    <span class="text-xs text-gray-400">Liquidity</span>
                    <span class="text-sm text-green-400">${liquidity}</span>
                  </div>
                  <div class="flex flex-col">
                    <span class="text-xs text-gray-400">Open Interest</span>
                    <span class="text-sm text-yellow-400">${openInterest}</span>
                  </div>
                  <div class="flex flex-col">
                    <span class="text-xs text-gray-400">24h Volume</span>
                    <span class="text-sm text-blue-400">${volume}</span>
                  </div>
                </div>
              `;
              
              // Add click event to dropdown item
              dropdownItem.addEventListener('click', () => {
                // Update the hidden select value
                marketSelect.value = market.address;
                
                // Update the button text
                selectedMarketText.textContent = market.pairName;
                
                // Hide the dropdown
                marketDropdownList.classList.add('hidden');
                
                // Trigger change event on the hidden select
                const event = new Event('change');
                marketSelect.dispatchEvent(event);
              });
              
              marketDropdownList.appendChild(dropdownItem);
            });
          });
          
          // Add custom styles for the chain headers
          const styleId = 'chain-dropdown-styles';
          if (!document.getElementById(styleId)) {
            const style = document.createElement('style');
            style.id = styleId;
            style.textContent = `
              .chain-header {
                position: sticky;
                top: 80px; /* Adjust based on your search box height */
                z-index: 10;
              }
            `;
            document.head.appendChild(style);
          }
          
          // Set up the dropdown toggle (reuse existing code)
          marketDropdownButton.addEventListener('click', () => {
            marketDropdownList.classList.toggle('hidden');
            // Focus search input when dropdown opens
            if (!marketDropdownList.classList.contains('hidden')) {
              setTimeout(() => {
                const searchInput = document.getElementById('marketSearchInput');
                if (searchInput) searchInput.focus();
              }, 100);
            }
          });
          
          // Set up market search
          const marketSearchInput = document.getElementById('marketSearchInput');
          if (marketSearchInput) {
            marketSearchInput.addEventListener('input', (e) => {
              const searchTerm = e.target.value.toLowerCase();
              const marketItems = marketDropdownList.querySelectorAll('div[data-value]');
              const chainHeaders = marketDropdownList.querySelectorAll('.chain-header');
              
              // Create a map to track if any markets are visible for each chain
              const visibleMarketsPerChain = {};
              
              // Check visibility of market items
              marketItems.forEach(item => {
                const marketName = item.querySelector('.font-semibold').textContent.toLowerCase();
                const chainId = item.dataset.chainId;
                const isVisible = marketName.includes(searchTerm);
                item.style.display = isVisible ? 'flex' : 'none';
                
                // Track visibility for each chain
                if (isVisible) {
                  visibleMarketsPerChain[chainId] = true;
                }
              });
              
              // Show/hide chain headers based on whether they have visible markets
              chainHeaders.forEach(header => {
                const nextElement = header.nextElementSibling;
                if (nextElement && nextElement.dataset && nextElement.dataset.chainId) {
                  const chainId = nextElement.dataset.chainId;
                  header.style.display = visibleMarketsPerChain[chainId] ? 'flex' : 'none';
                }
              });
            });
            
            // Prevent clicks inside search from closing dropdown
            marketSearchInput.addEventListener('click', (e) => {
              e.stopPropagation();
            });
          }
          
          // Get sort buttons
          const sortByName = document.getElementById('sortByName');
          const sortByLiquidity = document.getElementById('sortByLiquidity');
          const sortByVolume = document.getElementById('sortByVolume');
          
          // Function to set active sort button
          const setActiveSortButton = (activeButton) => {
            [sortByName, sortByLiquidity, sortByVolume].forEach(btn => {
              if (btn && btn === activeButton) {
                btn.classList.add('sort-active');
                btn.classList.add('text-green-400');
              } else if (btn) {
                btn.classList.remove('sort-active');
                btn.classList.remove('text-green-400');
              }
            });
          };
          
          // Override existing event listeners for sorting buttons
          if (sortByName) {
            sortByName.replaceWith(sortByName.cloneNode(true));
            const newSortByName = document.getElementById('sortByName');
            
            newSortByName.addEventListener('click', () => {
              setActiveSortButton(newSortByName);
              
              // For each chain section, sort its markets
              sortedChainIds.forEach(chainId => {
                const chainItems = Array.from(marketDropdownList.querySelectorAll(`div[data-value][data-chain-id="${chainId}"]`));
                const sortedItems = chainItems.sort((a, b) => {
                  const marketA = a.querySelector('.font-semibold').textContent;
                  const marketB = b.querySelector('.font-semibold').textContent;
                  return marketA.localeCompare(marketB);
                });
                
                // Find the chain header
                const chainHeader = Array.from(marketDropdownList.querySelectorAll('.chain-header')).find(header => 
                  header.textContent.trim().includes(CHAIN_DATA[chainId]?.name || `Chain ${chainId}`)
                );
                
                // Reorder DOM elements after the chain header
                if (chainHeader) {
                  let currentElement = chainHeader;
                  sortedItems.forEach(item => {
                    // Insert after the current element
                    currentElement.after(item);
                    // Update current element to the newly inserted one
                    currentElement = item;
                  });
                }
              });
            });
          }
          
          // Sort markets by liquidity
          if (sortByLiquidity) {
            sortByLiquidity.replaceWith(sortByLiquidity.cloneNode(true));
            const newSortByLiquidity = document.getElementById('sortByLiquidity');
            
            newSortByLiquidity.addEventListener('click', () => {
              setActiveSortButton(newSortByLiquidity);
              
              // For each chain section, sort its markets
              sortedChainIds.forEach(chainId => {
                const chainItems = Array.from(marketDropdownList.querySelectorAll(`div[data-value][data-chain-id="${chainId}"]`));
                const sortedItems = chainItems.sort((a, b) => {
                  const marketA = marketsData.find(m => m.address === a.dataset.value);
                  const marketB = marketsData.find(m => m.address === b.dataset.value);
                  return (marketB?.totalLiquidity || 0) - (marketA?.totalLiquidity || 0);
                });
                
                // Find the chain header
                const chainHeader = Array.from(marketDropdownList.querySelectorAll('.chain-header')).find(header => 
                  header.textContent.trim().includes(CHAIN_DATA[chainId]?.name || `Chain ${chainId}`)
                );
                
                // Reorder DOM elements after the chain header
                if (chainHeader) {
                  let currentElement = chainHeader;
                  sortedItems.forEach(item => {
                    // Insert after the current element
                    currentElement.after(item);
                    // Update current element to the newly inserted one
                    currentElement = item;
                  });
                }
              });
            });
          }
          
          // Sort markets by volume
          if (sortByVolume) {
            sortByVolume.replaceWith(sortByVolume.cloneNode(true));
            const newSortByVolume = document.getElementById('sortByVolume');
            
            newSortByVolume.addEventListener('click', () => {
              setActiveSortButton(newSortByVolume);
              
              // For each chain section, sort its markets
              sortedChainIds.forEach(chainId => {
                const chainItems = Array.from(marketDropdownList.querySelectorAll(`div[data-value][data-chain-id="${chainId}"]`));
                const sortedItems = chainItems.sort((a, b) => {
                  const marketA = marketsData.find(m => m.address === a.dataset.value);
                  const marketB = marketsData.find(m => m.address === b.dataset.value);
                  return (marketB?.volume24h || 0) - (marketA?.volume24h || 0);
                });
                
                // Find the chain header
                const chainHeader = Array.from(marketDropdownList.querySelectorAll('.chain-header')).find(header => 
                  header.textContent.trim().includes(CHAIN_DATA[chainId]?.name || `Chain ${chainId}`)
                );
                
                // Reorder DOM elements after the chain header
                if (chainHeader) {
                  let currentElement = chainHeader;
                  sortedItems.forEach(item => {
                    // Insert after the current element
                    currentElement.after(item);
                    // Update current element to the newly inserted one
                    currentElement = item;
                  });
                }
              });
            });
          }
          
          // Initially sort by liquidity
          if (sortByLiquidity) {
            setActiveSortButton(sortByLiquidity);
            
            // Trigger initial sort
            sortByLiquidity.click();
          }
          
          // Close dropdown when clicking outside
          document.addEventListener('click', (event) => {
            if (!marketDropdownButton.contains(event.target) && !marketDropdownList.contains(event.target)) {
              marketDropdownList.classList.add('hidden');
            }
          });
          
          // Trigger change event to load the first market
          if (marketSelect.options.length > 0 && firstMarketAddress) {
            console.log("Setting initial market:", firstMarketAddress);
            marketSelect.value = firstMarketAddress;
            
            // Also update the button text
            if (markets.length > 0) {
              const firstMarket = markets.find(m => m.address === firstMarketAddress);
              if (firstMarket) {
                selectedMarketText.textContent = firstMarket.pairName;
              }
            }
            
            // Ensure we wait for the market data to be fetched
            await fetchMarketData(firstMarketAddress);
            await fetchLiquidityData(firstMarketAddress);
            renderLiquidityChart();
            
            // Explicitly call loadTradePage to ensure all data is loaded correctly
            await loadTradePage(true);
            
            // Set option type to call and update UI
            document.getElementById("optionType").value = "call";
            const event = new Event('change');
            document.getElementById("optionType").dispatchEvent(event);
            
            // Set zoom preset
            setZoomPreset("50");
          }
        } catch (error) {
          console.error('Error fetching markets:', error);
        }
      }

      async function fetchMarketData(marketAddress) {
        try {
          console.log("Fetching data for market:", marketAddress);
          
          // Find the selected market in the stored markets data
          const market = marketsData.find(m => m.address === marketAddress);
          console.log("Market found:", market);
          
          if (!market) {
            console.error('Market not found');
            return;
          }
          
          selectedMarketData = market; // Store the selected market data globally
          
          // Fetch strikes data for the selected market
          console.log(`Fetching strikes for market: chainId=${market.chainId}, address=${market.address}`);
          const strikesResponse = await fetch(`https://api.stryke.xyz/clamm/strikes-chain?chainId=${market.chainId}&optionMarket=${market.address}&callsReach=1000&putsReach=1000&filterDeprecated=true`);
          const strikesData = await strikesResponse.json();
          console.log("Strikes data:", strikesData);
          
          // Fetch mark price for the selected market
          console.log(`Fetching mark price for market: chainId=${market.chainId}, ticker=${market.ticker}`);
          const markPriceResponse = await fetch(`https://api.stryke.xyz/uniswap-prices/mark-price?chainId=${market.chainId}&ticker=${market.ticker}`);
          const markPriceData = await markPriceResponse.json();
          console.log("Mark price data:", markPriceData);
          
          // Process each strike
          const liquidityData = [];
          const availableLiquidityData = [];
          
          strikesData.forEach(strike => {
            const strikePrice = Object.keys(strike)[0];
            const strikeData = strike[strikePrice][0];
            
            // Add total liquidity data
            liquidityData.push({
              x: parseFloat(strikePrice),
              y: parseFloat(strikeData.totalLiquidity)
            });
            
            // Add available liquidity data
            availableLiquidityData.push({
              x: parseFloat(strikePrice),
              y: parseFloat(strikeData.availableLiquidity)
            });
          });
          
          // Update UI with market data
          const marketInfo = {
            liquidity: market.totalLiquidity,
            availableLiquidity: market.availableLiquidity,
            openInterest: market.openInterest,
            volume24h: market.volume24h,
            markPrice: markPriceData.markPrice,
            pairName: market.pairName
          };
          
          console.log("Updating market info with:", marketInfo);
          updateMarketInfo(marketInfo);
          
          // Update charts with both total and available liquidity data
          updateCharts({
            liquidityData: liquidityData,
            availableLiquidityData: availableLiquidityData
          });
          
        } catch (error) {
          console.error('Error fetching and processing market data:', error);
        }
      }

      // Function to update charts with new data
      function updateCharts(data) {
        console.log("Updating charts with data:", data);
        
        // Update total liquidity chart
        if (totalLiquidityChartInstance) {
          console.log("Updating total liquidity chart");
          totalLiquidityChartInstance.data.datasets[0].data = data.liquidityData;
          totalLiquidityChartInstance.update();
        } else {
          console.log("Total liquidity chart instance not found");
        }
        
        // Update locked liquidity chart
        if (lockedLiquidityChartInstance) {
          console.log("Updating locked liquidity chart");
          // Calculate locked liquidity by subtracting available from total
          const lockedLiquidityData = data.liquidityData.map(point => ({
            x: point.x,
            y: point.y - (data.availableLiquidityData?.find(p => p.x === point.x)?.y || 0)
          }));
          lockedLiquidityChartInstance.data.datasets[0].data = lockedLiquidityData;
          lockedLiquidityChartInstance.update();
        } else {
          console.log("Locked liquidity chart instance not found");
        }
      }

      // Function to update market info panel
      function updateMarketInfo(data) {
        // Update the UI with the market information
        console.log("Updating UI with market info:", data);
        
        // Update the market name
        const marketNameElement = document.getElementById('marketName');
        if (marketNameElement) {
          marketNameElement.textContent = data.pairName;
        }
        
        // Update liquidity
        const liquidityElement = document.getElementById('totalLiquidity');
        if (liquidityElement) {
          liquidityElement.textContent = formatNumber(data.liquidity);
        }
        
        // Update open interest
        const openInterestElement = document.getElementById('openInterest');
        if (openInterestElement) {
          openInterestElement.textContent = formatNumber(data.openInterest);
        }
        
        // Update 24h volume
        const volume24hElement = document.getElementById('volume24h');
        if (volume24hElement) {
          volume24hElement.textContent = formatNumber(data.volume24h);
        }
        
        // Update mark price
        const markPriceElement = document.getElementById('markPrice');
        if (markPriceElement) {
          markPriceElement.textContent = formatNumber(data.markPrice);
        }
      }

      // Close dropdown when clicking outside
      document.addEventListener('click', (event) => {
        if (!marketDropdownButton.contains(event.target) && !marketDropdownList.contains(event.target)) {
          marketDropdownList.classList.add('hidden');
        }
      });

      // Helper function to format numbers for input fields
      function formatNumberForInput(num) {
        return parseFloat(num).toFixed(2);
      }

      // Event listeners for amount inputs and MAX buttons
      document.getElementById("callAmountInput").addEventListener("input", function(e) {
        const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
        const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
        
        // Calculate available liquidity
        const callRange = window.processedLiquidityData.filter(p => p.strike >= callMin && p.strike <= callMax);
        const totalAvailable = callRange.reduce((sum, p) => sum + p.avail, 0);
        
        // Get input value and clamp it to available liquidity
        let value = parseFloat(e.target.value) || 0;
        value = Math.min(value, totalAvailable);
        
        // Calculate percentage for slider
        const percentage = totalAvailable > 0 ? Math.floor((value / totalAvailable) * 100) : 0;
        
        // Update slider value
        document.getElementById("tradeAmountCall").value = percentage;
        
        // Update chart
        updateChartColors();
      });
      
      document.getElementById("putAmountInput").addEventListener("input", function(e) {
        const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
        const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
        
        // Calculate available liquidity
        const putRange = window.processedLiquidityData.filter(p => p.strike >= putMin && p.strike <= putMax);
        const totalAvailable = putRange.reduce((sum, p) => sum + p.avail, 0);
        
        // Get input value and clamp it to available liquidity
        let value = parseFloat(e.target.value) || 0;
        value = Math.min(value, totalAvailable);
        
        // Calculate percentage for slider
        const percentage = totalAvailable > 0 ? Math.floor((value / totalAvailable) * 100) : 0;
        
        // Update slider value
        document.getElementById("tradeAmountPut").value = percentage;
        
        // Update chart
        updateChartColors();
      });
      
      document.getElementById("callMaxButton").addEventListener("click", function() {
        const callMin = parseFloat(document.getElementById("callMinInput").value) || spotPriceGlobal;
        const callMax = parseFloat(document.getElementById("callMaxInput").value) || (spotPriceGlobal * 1.05);
        
        // Calculate available liquidity
        const callRange = window.processedLiquidityData.filter(p => p.strike >= callMin && p.strike <= callMax);
        const totalAvailable = callRange.reduce((sum, p) => sum + p.avail, 0);
        
        // Set input to max available
        document.getElementById("callAmountInput").value = formatNumberForInput(totalAvailable);
        
        // Set slider to 100%
        document.getElementById("tradeAmountCall").value = 100;
        
        // Update chart
        updateChartColors();
      });
      
      document.getElementById("putMaxButton").addEventListener("click", function() {
        const putMin = parseFloat(document.getElementById("putMinInput").value) || (spotPriceGlobal * 0.95);
        const putMax = parseFloat(document.getElementById("putMaxInput").value) || spotPriceGlobal;
        
        // Calculate available liquidity
        const putRange = window.processedLiquidityData.filter(p => p.strike >= putMin && p.strike <= putMax);
        const totalAvailable = putRange.reduce((sum, p) => sum + p.avail, 0);
        
        // Set input to max available
        document.getElementById("putAmountInput").value = formatNumberForInput(totalAvailable);
        
        // Set slider to 100%
        document.getElementById("tradeAmountPut").value = 100;
        
        // Update chart
        updateChartColors();
      });
    </script>
  </body>
</html>
