<!DOCTYPE html>
<html lang="en" class="dark">
  <head>
    <meta charset="UTF-8" />
    <title>Stryke.xyz - Trade</title>
    <!-- Import Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js and Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0"></script>
    <!-- Tippy.js for tooltips -->
    <link rel="stylesheet" href="https://unpkg.com/tippy.js@6/animations/shift-away.css" />
    <script src="https://unpkg.com/@popperjs/core@2"></script>
    <script src="https://unpkg.com/tippy.js@6"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            fontFamily: { sans: ['Inter', 'sans-serif'] },
            colors: { primary: '#FBBF24' },
            backgroundImage: {
              'hero-light': 'linear-gradient(135deg, rgba(255,255,255,0.9), rgba(243,244,246,0.9))',
              'hero-dark': 'linear-gradient(135deg, rgba(31,41,55,0.9), rgba(55,65,81,0.9))',
            },
            boxShadow: {
              'card': '0 4px 6px rgba(0,0,0,0.1)',
              'float': '0 10px 15px rgba(0,0,0,0.1)',
            },
          }
        }
      }
    </script>
  </head>
  <body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100 transition-colors duration-300">
    <!-- Sidebar -->
    <div class="min-h-screen flex">
      <aside class="w-64 bg-white dark:bg-gray-800 shadow-lg">
        <div class="p-6">
          <!-- Stryke logo updated -->
          <img src="https://i.ibb.co/FLF1CX6D/Logomark-White-Transparent.png" alt="Stryke Logo" class="inline-block mr-2 rounded-full shadow-sm" />
        </div>
        <nav class="mt-6">
          <a href="trade.html" class="block px-6 py-3 text-lg font-medium text-yellow-500 dark:text-yellow-400 border-l-4 border-yellow-500">Trade</a>
          <a href="earn.html" class="block px-6 py-3 text-lg font-medium hover:bg-yellow-100 dark:hover:bg-gray-700 transition">Earn</a>
        </nav>
      </aside>
      
      <!-- Main Content -->
      <main class="flex-1 p-6">
        <!-- Top Navbar for Mobile -->
        <div class="flex justify-between items-center mb-4 sm:hidden">
          <h1 class="text-2xl font-bold">Trade</h1>
          <button id="modeToggle" class="p-2 rounded-full bg-gray-200 dark:bg-gray-700 transition transform hover:scale-105 focus:outline-none">
            <svg id="sunIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-yellow-500 dark:hidden" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m8.66-9H21m-16 0H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M12 8a4 4 0 110 8 4 4 0 010-8z" />
            </svg>
            <svg id="moonIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-yellow-500 hidden dark:block" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />
            </svg>
          </button>
        </div>
        
        <!-- Hero Banner -->
        <section class="mb-6 p-8 rounded-lg shadow-lg bg-hero-light dark:bg-hero-dark relative overflow-hidden">
          <img src="https://www.stryke.xyz/images/carousel/sonic_launch.webp" alt="Banner" class="w-full h-48 object-cover rounded-lg filter brightness-75" />
          <div class="absolute inset-0 bg-black opacity-30"></div>
          <div class="relative z-10 mt-4">
            <h1 class="text-4xl sm:text-5xl font-bold mb-2">Trade Options</h1>
            <p class="text-xl sm:text-2xl text-gray-700 dark:text-gray-300">
              Execute seamless, permissionless options trades with precision.
            </p>
          </div>
        </section>
        
        <!-- Trade Form Card -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
          <h2 class="text-2xl font-semibold mb-4">Trade</h2>
          <!-- Underlying Asset Pair Card -->
          <div id="assetPair" class="relative w-24 h-24 mb-4">
            <!-- Main asset logo (will be updated via JS based on market selection) -->
            <img id="assetLogo" src="" alt="Asset Logo" class="w-full h-full object-contain rounded-full shadow-lg" />
            <!-- USDC logo overlay at bottom-right -->
            <img src="https://www.stryke.xyz/images/tokens/usdc.svg" alt="USDC" class="absolute bottom-0 right-0 w-8 h-8 object-contain border-2 border-white dark:border-gray-800 rounded-full shadow-md" />
          </div>
          <div class="grid grid-cols-1 sm:grid-cols-5 gap-4">
            <div>
              <label for="marketSelect" class="block text-sm font-medium">Market</label>
              <select id="marketSelect" class="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 focus:ring focus:ring-yellow-500 transition">
                <option value="S">wS/USDC</option>
                <option value="ETH">wETH/USDC</option>
              </select>
            </div>
            <div>
              <label for="expirySelect" class="block text-sm font-medium">Expiry</label>
              <select id="expirySelect" class="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 focus:ring focus:ring-yellow-500 transition">
                <option value="3600">1h</option>
                <option value="7200">2h</option>
                <option value="21600">6h</option>
                <option value="43200">12h</option>
                <option value="86400">24h</option>
                <option value="604800">1 week</option>
              </select>
            </div>
            <div>
              <label for="optionType" class="block text-sm font-medium">Option Type</label>
              <select id="optionType" class="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 focus:ring focus:ring-yellow-500 transition">
                <option value="call">Call</option>
                <option value="put">Put</option>
              </select>
            </div>
            <div>
              <label for="strikeInput" class="block text-sm font-medium">Strike Price</label>
              <input type="number" id="strikeInput" step="0.0001" value="0.72" class="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring focus:ring-yellow-500 transition" />
            </div>
            <div>
              <label for="tradeAmount" class="block text-sm font-medium">Amount</label>
              <input type="number" id="tradeAmount" step="any" value="100" class="mt-1 block w-full rounded-md border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 text-gray-900 dark:text-gray-100 focus:outline-none focus:ring focus:ring-yellow-500 transition" />
            </div>
          </div>
          <div class="mt-4">
            <button id="submitBtn" class="px-6 py-2 bg-yellow-500 hover:bg-yellow-600 text-black font-medium rounded-md transition shadow">Submit</button>
          </div>
        </div>
        
        <!-- Liquidity Details Card -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
          <h2 class="text-2xl font-semibold mb-4">Details</h2>
          <div class="overflow-x-auto">
            <table id="liquidityTable" class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <!-- Table content injected via JavaScript -->
            </table>
          </div>
        </div>
        
        <!-- Chart Card -->
        <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6 mb-6">
          <div class="flex justify-between items-center mb-4">
            <h2 id="chartTitle" class="text-2xl font-semibold">PnL Chart</h2>
            <button id="toggleChartBtn" class="px-4 py-2 bg-gray-300 dark:bg-gray-600 text-black font-medium rounded-md transition hidden">Show Liquidity Chart</button>
          </div>
          <div class="bg-gray-100 dark:bg-gray-700 rounded-lg p-4">
            <canvas id="chartCanvas" class="w-full" height="400"></canvas>
          </div>
        </div>
      </main>
    </div>
    
    <!-- Trade Page JavaScript -->
    <script>
      // Global variables for chart and trade calculations
      let filteredTicks = [];
      let chosenTicks = [];
      let totalPremium = 0;
      let underlyingPrices = [];
      let payoffCurve = [];
      let currentChartType = "PnL";
      let myChart = null;
      let globalOptionType = "";
      let exposureFilledStrikeGlobal = 0;
      let spotPriceGlobal = 0;
      
      // Market configuration for trade.
      const marketConfigTrade = {
        "S": {
          optionMarket: "0x342e4068bA07bbCcBDDE503b2451FAa3D3C0278B",
          spotApi: "https://api.stryke.xyz/uniswap-prices/mark-price?chainId=146&ticker=WS/USDC.e"
        },
        "ETH": {
          optionMarket: "0x9d3828e89Fadc4DEc77758988b388435Fe0f8DCa",
          spotApi: "https://api.stryke.xyz/uniswap-prices/mark-price?chainId=146&ticker=WETH/USDC.e"
        }
      };
      
      const intradayHook = "0x78d96C07B16d8f911c4cD14EE10601921E4fb8aF";
      const weeklyHook = "0xf6314300b42B7D88c153348921a95d3CA95E74Bd";
      
      function destroyChart() {
        if (myChart instanceof Chart) {
          myChart.destroy();
        }
      }
      
      async function fetchSpotPriceTrade(market) {
        const url = marketConfigTrade[market].spotApi;
        try {
          const response = await fetch(url);
          const data = await response.json();
          return parseFloat(data.markPrice);
        } catch (error) {
          console.error("Error fetching spot price:", error);
          return 0;
        }
      }
      
      function renderPnLChart() {
        let breakeven = null;
        for (let i = 1; i < payoffCurve.length; i++) {
          if (globalOptionType === 'call') {
            if (payoffCurve[i - 1] < totalPremium && payoffCurve[i] >= totalPremium) {
              const x1 = underlyingPrices[i - 1];
              const y1 = payoffCurve[i - 1];
              const x2 = underlyingPrices[i];
              const y2 = payoffCurve[i];
              breakeven = x1 + ((totalPremium - y1) * (x2 - x1)) / (y2 - y1);
              break;
            }
          } else {
            if (payoffCurve[i - 1] > totalPremium && payoffCurve[i] <= totalPremium) {
              const x1 = underlyingPrices[i - 1];
              const y1 = payoffCurve[i - 1];
              const x2 = underlyingPrices[i];
              const y2 = payoffCurve[i];
              breakeven = x1 + ((y1 - totalPremium) * (x2 - x1)) / (y1 - y2);
              break;
            }
          }
        }
        if (breakeven === null) {
          breakeven = underlyingPrices[underlyingPrices.length - 1];
        }
        
        const ctx = document.getElementById('chartCanvas').getContext('2d');
        destroyChart();
        myChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: underlyingPrices,
            datasets: [{
              label: 'Cumulative Payoff',
              data: payoffCurve,
              borderColor: "#ffcc00",
              fill: false,
              tension: 0.2
            }]
          },
          options: {
            scales: {
              x: {
                type: 'linear',
                position: 'bottom',
                title: { display: true, text: 'Price', color: "#ffcc00" },
                min: underlyingPrices[0],
                max: underlyingPrices[underlyingPrices.length - 1],
                ticks: {
                  color: "#fff",
                  callback: function(value) { return value.toFixed(4); }
                },
                grid: { color: "rgba(255,255,255,0.2)" }
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Cumulative Payoff', color: "#ffcc00" },
                ticks: { color: "#fff" },
                grid: { color: "rgba(255,255,255,0.2)" }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const x = context.parsed.x;
                    let exposure = 0;
                    if (globalOptionType === 'call') {
                      chosenTicks.forEach(tick => { if (tick.strike <= x) exposure += tick.usedLiquidity; });
                    } else {
                      chosenTicks.forEach(tick => { if (tick.strike >= x) exposure += tick.usedLiquidity; });
                    }
                    return context.dataset.label + ': ' + context.parsed.y.toFixed(4) + ' (Exposure: ' + exposure + ')';
                  }
                }
              },
              annotation: {
                annotations: {
                  premiumLine: {
                    type: 'line',
                    mode: 'horizontal',
                    scaleID: 'y',
                    value: totalPremium,
                    borderColor: 'green',
                    borderWidth: 2,
                    label: { enabled: true, content: 'Total Premium', color: "#fff" }
                  },
                  breakevenLine: {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: breakeven,
                    borderColor: 'red',
                    borderWidth: 2,
                    label: { enabled: true, content: 'Breakeven', color: "#fff" }
                  },
                  exposureLine: {
                    type: 'line',
                    mode: 'vertical',
                    scaleID: 'x',
                    value: exposureFilledStrikeGlobal,
                    borderColor: 'orange',
                    borderWidth: 2,
                    label: { enabled: true, content: 'Exposure Filled', color: "#fff" }
                  }
                }
              }
            }
          }
        });
        document.getElementById('chartTitle').innerText = "PnL Chart";
      }
      
      function renderLiquidityChart() {
        const labels = chosenTicks.map(tick => tick.strike.toFixed(4));
        const usedData = chosenTicks.map(tick => tick.usedLiquidity);
        const remainingData = chosenTicks.map(tick => tick.totalLiquidity - tick.usedLiquidity);
        const usedColors = chosenTicks.map(() => '#ffcc00');
        
        const ctx = document.getElementById('chartCanvas').getContext('2d');
        destroyChart();
        myChart = new Chart(ctx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [
              { label: 'Liquidity Purchased', data: usedData, backgroundColor: usedColors },
              { label: 'Total Liquidity', data: remainingData, backgroundColor: 'rgba(128,128,128,0.8)' }
            ]
          },
          options: {
            responsive: true,
            plugins: {
              title: { display: true, text: 'Liquidity Breakdown', color: "#ffcc00" }
            },
            scales: {
              x: { stacked: true, title: { display: true, text: 'Price', color: "#ffcc00" }, ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.2)" } },
              y: { stacked: true, beginAtZero: true, title: { display: true, text: 'Liquidity', color: "#ffcc00" }, ticks: { color: "#fff" }, grid: { color: "rgba(255,255,255,0.2)" } }
            }
          }
        });
        document.getElementById('chartTitle').innerText = "Purchase Distribution";
      }
      
      document.getElementById('toggleChartBtn').addEventListener('click', function() {
        if (currentChartType === "PnL") {
          currentChartType = "Liquidity";
          this.innerText = "Show PnL Chart";
          renderLiquidityChart();
        } else {
          currentChartType = "PnL";
          this.innerText = "Show Liquidity Chart";
          renderPnLChart();
        }
      });
      
      // Trade form submission & data processing.
      document.getElementById('submitBtn').addEventListener('click', async function() {
        // Update asset pair image based on market selection.
        const marketChoice = document.getElementById('marketSelect').value;
        const assetLogo = document.getElementById('assetLogo');
        if (marketChoice === "ETH") {
          assetLogo.src = "https://www.stryke.xyz/images/tokens/weth.svg";
        } else {
          assetLogo.src = "https://www.stryke.xyz/images/tokens/ws.svg";
        }
        
        const ttlSeconds = parseInt(document.getElementById('expirySelect').value);
        const optionType = document.getElementById('optionType').value;
        globalOptionType = optionType;
        const strikeInput = parseFloat(document.getElementById('strikeInput').value);
        const tradeAmount = parseFloat(document.getElementById('tradeAmount').value);
        const userAddress = "0xf8859BAae87Eac4C7EE0b81499eDDD99c778FBEB";
        
        const optionMarket = marketConfigTrade[marketChoice].optionMarket;
        spotPriceGlobal = await fetchSpotPriceTrade(marketChoice);
        console.log("Spot Price:", spotPriceGlobal);
        
        const liquidityUrl = `https://api.stryke.xyz/clamm/strikes-chain?chainId=146&optionMarket=${optionMarket}&callsReach=800&putsReach=800&filterDeprecated=true`;
        try {
          const liquidityResponse = await fetch(liquidityUrl);
          const liquidityData = await liquidityResponse.json();
          
          let allTicks = [];
          liquidityData.forEach(item => {
            for (let key in item) {
              const data = item[key][0];
              const decimals = data.token.decimals;
              const rawAvail = parseFloat(data.meta.availableTokenLiquidity);
              const rawTotal = parseFloat(data.meta.totalTokenLiquidity);
              const scaledAvail = rawAvail / Math.pow(10, decimals);
              const scaledTotal = rawTotal / Math.pow(10, decimals);
  
              allTicks.push({
                strike: parseFloat(key),
                availableLiquidity: scaledAvail,
                totalLiquidity: scaledTotal,
                tokenSymbol: data.token.symbol,
                hook: data.meta.hook
              });
            }
          });
          
          let allowedHooks = [];
          if (ttlSeconds < 604800) {
            allowedHooks = [intradayHook.toLowerCase(), weeklyHook.toLowerCase()];
          } else {
            allowedHooks = [weeklyHook.toLowerCase()];
          }
          
          let filteredTicks = [];
          if (optionType === 'call') {
            filteredTicks = allTicks.filter(tick =>
              tick.strike >= strikeInput &&
              (tick.tokenSymbol.toLowerCase().includes("ws") || tick.tokenSymbol.toLowerCase().includes("weth")) &&
              allowedHooks.includes(tick.hook.toLowerCase())
            );
            filteredTicks.sort((a, b) => a.strike - b.strike);
          } else {
            filteredTicks = allTicks.filter(tick =>
              tick.strike <= strikeInput &&
              tick.tokenSymbol.toLowerCase().includes("usdc") &&
              allowedHooks.includes(tick.hook.toLowerCase())
            );
            filteredTicks.sort((a, b) => b.strike - a.strike);
          }
          
          chosenTicks = [];
          let cumulative = 0;
          for (let i = 0; i < filteredTicks.length; i++) {
            if (cumulative >= tradeAmount) break;
            let tick = Object.assign({}, filteredTicks[i]);
            let needed = tradeAmount - cumulative;
            if (tick.availableLiquidity >= needed) {
              tick.usedLiquidity = needed;
              cumulative += needed;
            } else {
              tick.usedLiquidity = tick.availableLiquidity;
              cumulative += tick.availableLiquidity;
            }
            chosenTicks.push(tick);
          }
          
          if (chosenTicks.length === 0) {
            alert("No sufficient liquidity available for the given trade amount at this strike.");
            return;
          }
          
          exposureFilledStrikeGlobal = chosenTicks[chosenTicks.length - 1].strike;
          
          const premiumPromises = chosenTicks.map(tick => {
            const tickQuoteUrl = `https://api.stryke.xyz/clamm/purchase/quote?chainId=146&optionMarket=${optionMarket}&user=${userAddress}&strike=${tick.strike}&markPrice=${spotPriceGlobal}&type=${optionType}&amount=${tick.usedLiquidity}&ttl=${ttlSeconds}`;
            return fetch(tickQuoteUrl)
              .then(res => res.json())
              .then(data => {
                console.log("Premium Quote Response for strike:", tick.strike, data);
                const decimals = data.token.decimals;
                const premiumValue = parseFloat(data.premium) / Math.pow(10, decimals);
                return premiumValue;
              })
              .catch(err => {
                console.error("Error fetching premium for tick", tick.strike, err);
                return 0;
              });
          });
          const chosenTickPremiums = await Promise.all(premiumPromises);
          chosenTicks.forEach((tick, index) => {
            tick.premiumCost = chosenTickPremiums[index];
          });
          totalPremium = chosenTicks.reduce((sum, tick) => sum + tick.premiumCost, 0);
          
          // Render the breakdown table (unchanged styling)
          const table = document.getElementById('liquidityTable');
          table.innerHTML = `
            <tr>
              <th class="px-4 py-2 text-left text-sm font-semibold uppercase tracking-wider">Range</th>
              <th class="px-4 py-2 text-left text-sm font-semibold uppercase tracking-wider">Amount</th>
              <th class="px-4 py-2 text-left text-sm font-semibold uppercase tracking-wider">Premium</th>
              <th class="px-4 py-2 text-left text-sm font-semibold uppercase tracking-wider">Token</th>
              <th class="px-4 py-2 text-left text-sm font-semibold uppercase tracking-wider">Breakdown</th>
            </tr>
          `;
          if (chosenTicks.length > 0) {
            const firstStrike = chosenTicks[0].strike;
            const lastStrike = chosenTicks[chosenTicks.length - 1].strike;
            const usedLiquiditySum = chosenTicks.reduce((sum, t) => sum + t.usedLiquidity, 0);
            const summaryRow = document.createElement('tr');
            summaryRow.innerHTML = `
              <td class="px-4 py-2">${firstStrike.toFixed(4)} - ${lastStrike.toFixed(4)}</td>
              <td class="px-4 py-2">${usedLiquiditySum}</td>
              <td class="px-4 py-2">${totalPremium.toFixed(4)}</td>
              <td class="px-4 py-2">${chosenTicks[0].tokenSymbol}</td>
              <td class="px-4 py-2">
                <details class="group">
                  <summary class="cursor-pointer bg-gray-200 dark:bg-gray-700 rounded-md px-2 py-1 inline-block">Show Breakdown</summary>
                  <table class="w-full mt-2 border-collapse">
                    <tr class="bg-gray-100 dark:bg-gray-600">
                      <th class="px-2 py-1 border text-xs font-semibold">Strike</th>
                      <th class="px-2 py-1 border text-xs font-semibold">Amount</th>
                      <th class="px-2 py-1 border text-xs font-semibold">Premium</th>
                      <th class="px-2 py-1 border text-xs font-semibold">Token</th>
                    </tr>
                  </table>
                </details>
              </td>
            `;
            table.appendChild(summaryRow);
            const detailsElem = summaryRow.querySelector('details');
            const breakdownTable = detailsElem.querySelector('table');
            chosenTicks.forEach(tick => {
              const row = document.createElement('tr');
              row.innerHTML = `
                <td class="px-2 py-1 border">${tick.strike.toFixed(4)}</td>
                <td class="px-2 py-1 border">${tick.usedLiquidity}</td>
                <td class="px-2 py-1 border">${tick.premiumCost.toFixed(4)}</td>
                <td class="px-2 py-1 border">${tick.tokenSymbol}</td>
              `;
              breakdownTable.appendChild(row);
            });
          }
          
          // Build chart data.
          underlyingPrices = [];
          payoffCurve = [];
          let lower, upper;
          if (optionType === 'put') {
            chosenTicks.sort((a, b) => a.strike - b.strike);
          }
          lower = chosenTicks[0].strike;
          upper = chosenTicks[chosenTicks.length - 1].strike;
          const rangeMin = lower * 0.95;
          const rangeMax = upper * 1.05;
          const steps = 50;
          const stepSize = (rangeMax - rangeMin) / steps;
          for (let price = rangeMin; price <= rangeMax; price += stepSize) {
            underlyingPrices.push(price);
            let cumulativePayoff = 0;
            if (optionType === 'call') {
              chosenTicks.forEach(t => {
                cumulativePayoff += Math.max(price - t.strike, 0) * t.usedLiquidity;
              });
            } else {
              chosenTicks.forEach(t => {
                cumulativePayoff += Math.max(t.strike - price, 0) * t.usedLiquidity;
              });
            }
            payoffCurve.push(cumulativePayoff);
          }
          
          document.getElementById('toggleChartBtn').style.display = "inline-block";
          currentChartType = "PnL";
          document.getElementById('toggleChartBtn').innerText = "Show Liquidity Chart";
          renderPnLChart();
          
        } catch (error) {
          console.error("Error fetching or processing data:", error);
        }
      });
      
      // Event Listeners for Trade Page
      function fetchSpotPriceTrade(market) {
        const url = marketConfigTrade[market].spotApi;
        return fetch(url)
          .then(res => res.json())
          .then(data => parseFloat(data.markPrice))
          .catch(err => {
            console.error("Error fetching spot price (trade):", err);
            return 0;
          });
      }
      
      document.getElementById('submitBtn').addEventListener('click', () => {
        loadEarnPage(); // For demo purposes, calling the same function.
      });
    </script>
  </body>
</html>
